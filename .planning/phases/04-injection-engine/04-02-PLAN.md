---
phase: 04-injection-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ricochet/injection/parser.py
  - ricochet/injection/vectors.py
  - ricochet/injection/__init__.py
autonomous: true

must_haves:
  truths:
    - "Parser correctly reads Burp-format request files with CRLF line endings"
    - "Parser extracts method, path, headers, and body from raw HTTP"
    - "Vector extractor identifies query params, headers, cookies, and body fields"
  artifacts:
    - path: "ricochet/injection/parser.py"
      provides: "Burp request file parsing"
      exports: ["ParsedRequest", "parse_request_file"]
    - path: "ricochet/injection/vectors.py"
      provides: "Injection vector extraction"
      exports: ["InjectionVector", "extract_vectors"]
  key_links:
    - from: "ricochet/injection/parser.py"
      to: "http.client.parse_headers"
      via: "RFC 5322 header parsing"
      pattern: "parse_headers"
    - from: "ricochet/injection/vectors.py"
      to: "urllib.parse"
      via: "query string parsing"
      pattern: "parse_qsl"
---

<objective>
Build the Burp request file parser and injection vector extractor.

Purpose: Enable users to provide raw HTTP request files (exported from Burp Suite) and automatically identify all injectable parameters across query strings, headers, cookies, and request bodies.

Output: Parser and vector extraction modules that turn raw HTTP into structured injection targets.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-injection-engine/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Burp request file parser</name>
  <files>
    ricochet/injection/parser.py
    ricochet/injection/__init__.py
  </files>
  <action>
Create `parser.py` with Burp-format request file parser:

1. `ParsedRequest` dataclass:
   ```python
   @dataclass
   class ParsedRequest:
       method: str           # GET, POST, etc.
       path: str             # /path?query=value
       http_version: str     # HTTP/1.1
       headers: dict[str, str]
       body: Optional[bytes]
       host: str             # From Host header
   ```

2. `parse_request_file(content: bytes) -> ParsedRequest`:
   - **Critical: Accept bytes, not str** - Burp exports use CRLF (`\r\n`)
   - Split on `b'\r\n'` to get lines
   - Parse first line: `METHOD PATH HTTP/VERSION`
   - Find header/body boundary: `\r\n\r\n`
   - Use `http.client.parse_headers()` with `io.BytesIO` for header parsing
   - Extract `Host` header (required for URL construction)
   - Return `ParsedRequest` with all fields populated

   **Edge cases:**
   - Handle missing HTTP version (default to HTTP/1.1)
   - Handle missing body (set to None)
   - Handle lowercase Host header (`host` vs `Host`)
   - Raise `ValueError` for empty or malformed request files

3. `parse_request_string(content: str) -> ParsedRequest`:
   - Convenience wrapper that converts string to bytes (handling LF -> CRLF if needed)
   - Detect line endings and normalize to CRLF before parsing

Update `__init__.py` to export `ParsedRequest` and `parse_request_file`.
  </action>
  <verify>
```python
python3 -c "
from ricochet.injection.parser import parse_request_file, ParsedRequest

# Test CRLF format (Burp export)
burp_request = b'POST /login HTTP/1.1\r\nHost: example.com\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\nusername=admin&password=secret'

parsed = parse_request_file(burp_request)
assert parsed.method == 'POST'
assert parsed.path == '/login'
assert parsed.host == 'example.com'
assert parsed.body == b'username=admin&password=secret'
assert 'Content-Type' in parsed.headers
print('Burp request parsing OK')

# Test GET without body
get_request = b'GET /api/users?id=123 HTTP/1.1\r\nHost: api.example.com\r\n\r\n'
parsed = parse_request_file(get_request)
assert parsed.method == 'GET'
assert parsed.path == '/api/users?id=123'
assert parsed.body is None
print('GET request parsing OK')
"
```
  </verify>
  <done>ParsedRequest dataclass and parse_request_file function correctly parse Burp-format HTTP request files</done>
</task>

<task type="auto">
  <name>Task 2: Create injection vector extractor</name>
  <files>
    ricochet/injection/vectors.py
    ricochet/injection/__init__.py
  </files>
  <action>
Create `vectors.py` with injection vector extraction:

1. `InjectionVector` dataclass:
   ```python
   @dataclass
   class InjectionVector:
       location: Literal['query', 'header', 'cookie', 'body', 'json']
       name: str
       original_value: str
   ```

2. `extract_vectors(request: ParsedRequest) -> list[InjectionVector]`:
   Extract all injectable parameters:

   **Query parameters:**
   - Use `urllib.parse.urlparse(request.path)` to get query string
   - Use `urllib.parse.parse_qsl(query, keep_blank_values=True)` to parse
   - Create vector for each parameter

   **Headers (security-relevant only):**
   ```python
   INJECTABLE_HEADERS = {
       'User-Agent', 'Referer', 'X-Forwarded-For', 'X-Forwarded-Host',
       'X-Custom-IP-Authorization', 'X-Original-URL', 'X-Rewrite-URL',
       'X-Client-IP', 'True-Client-IP', 'Forwarded', 'Origin'
   }
   ```
   - Create vector for each present injectable header

   **Cookies:**
   - Parse `Cookie` header: split on `;`, then each on `=`
   - Create vector for each cookie

   **Body (form-urlencoded):**
   - Check `Content-Type` header for `application/x-www-form-urlencoded`
   - Use `parse_qsl()` on decoded body
   - Create vector for each field

   **Body (JSON):**
   - Check `Content-Type` header for `application/json`
   - Parse with `json.loads()`
   - Extract top-level string fields only (recursive extraction is future work)
   - Mark location as 'json' to distinguish from form fields

Update `__init__.py` to export `InjectionVector` and `extract_vectors`.
  </action>
  <verify>
```python
python3 -c "
from ricochet.injection.parser import parse_request_file
from ricochet.injection.vectors import extract_vectors, InjectionVector

# Test comprehensive extraction
request = b'''POST /search?q=test&page=1 HTTP/1.1\r
Host: example.com\r
User-Agent: Mozilla/5.0\r
Cookie: session=abc123; user=admin\r
Content-Type: application/x-www-form-urlencoded\r
\r
query=hello&filter=active'''

parsed = parse_request_file(request)
vectors = extract_vectors(parsed)

# Should find: q, page (query), User-Agent (header), session, user (cookies), query, filter (body)
locations = {(v.location, v.name) for v in vectors}
assert ('query', 'q') in locations
assert ('query', 'page') in locations
assert ('header', 'User-Agent') in locations
assert ('cookie', 'session') in locations
assert ('cookie', 'user') in locations
assert ('body', 'query') in locations
assert ('body', 'filter') in locations
print(f'Found {len(vectors)} vectors: OK')

# Test JSON body
json_request = b'''POST /api HTTP/1.1\r
Host: api.example.com\r
Content-Type: application/json\r
\r
{\"username\": \"admin\", \"role\": \"user\", \"count\": 5}'''

parsed = parse_request_file(json_request)
vectors = extract_vectors(parsed)
json_vectors = [v for v in vectors if v.location == 'json']
assert len(json_vectors) == 2  # username and role (strings only, not count)
print('JSON extraction OK')
"
```
  </verify>
  <done>InjectionVector dataclass and extract_vectors function identify all injectable parameters in query, headers, cookies, and body</done>
</task>

<task type="auto">
  <name>Task 3: Add URL construction helper</name>
  <files>
    ricochet/injection/parser.py
  </files>
  <action>
Add URL construction helper to `parser.py`:

1. `build_url(request: ParsedRequest, use_https: bool = False) -> str`:
   - Construct full URL from ParsedRequest
   - Use scheme based on `use_https` parameter
   - Handle Host header that includes port (e.g., `example.com:8080`)
   - Combine: `{scheme}://{host}{path}`

2. `inject_into_path(request: ParsedRequest, param: str, value: str) -> ParsedRequest`:
   - Replace a query parameter value in the path
   - Use `urllib.parse.urlparse`, `parse_qsl`, `urlencode`, `urlunparse`
   - Return new ParsedRequest with modified path
   - **Critical: Do not modify the original request object**

Test with:
- Standard URL construction
- URL with explicit port in Host header
- Query parameter injection
  </action>
  <verify>
```python
python3 -c "
from ricochet.injection.parser import parse_request_file, build_url, inject_into_path

request = b'GET /api?id=123&name=test HTTP/1.1\r\nHost: example.com:8080\r\n\r\n'
parsed = parse_request_file(request)

# Test URL construction
url = build_url(parsed, use_https=False)
assert url == 'http://example.com:8080/api?id=123&name=test'
print(f'URL construction OK: {url}')

url_https = build_url(parsed, use_https=True)
assert url_https == 'https://example.com:8080/api?id=123&name=test'
print(f'HTTPS URL OK: {url_https}')

# Test injection
modified = inject_into_path(parsed, 'id', 'INJECTED')
assert 'INJECTED' in modified.path
assert '123' not in modified.path
assert parsed.path != modified.path  # Original unchanged
print('Parameter injection OK')
"
```
  </verify>
  <done>build_url constructs full URLs from ParsedRequest, inject_into_path replaces query parameter values without mutating original</done>
</task>

</tasks>

<verification>
All tasks complete when:
1. `python3 -c "from ricochet.injection import ParsedRequest, InjectionVector, extract_vectors"` succeeds
2. Parser handles both CRLF and LF line endings
3. Vector extraction finds query params, injectable headers, cookies, form body, JSON body
4. URL construction handles ports correctly
5. Parameter injection creates new ParsedRequest without mutating original
</verification>

<success_criteria>
- ParsedRequest correctly represents raw HTTP request structure
- parse_request_file handles Burp export format (CRLF line endings)
- extract_vectors identifies all injectable parameters across all locations
- build_url constructs valid URLs including port handling
- inject_into_path enables clean parameter value replacement
- All functions use stdlib only (http.client, urllib.parse, json)
</success_criteria>

<output>
After completion, create `.planning/phases/04-injection-engine/04-02-SUMMARY.md`
</output>
