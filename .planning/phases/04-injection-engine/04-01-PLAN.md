---
phase: 04-injection-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ricochet/injection/__init__.py
  - ricochet/injection/http_client.py
  - ricochet/injection/rate_limiter.py
autonomous: true

must_haves:
  truths:
    - "HTTP client can send requests with custom method, headers, and body"
    - "Requests respect configurable timeout"
    - "Rate limiter prevents exceeding requests per second"
  artifacts:
    - path: "ricochet/injection/__init__.py"
      provides: "Package initialization"
    - path: "ricochet/injection/http_client.py"
      provides: "HTTP request sending with urllib.request"
      exports: ["HttpResponse", "send_request"]
    - path: "ricochet/injection/rate_limiter.py"
      provides: "Token bucket rate limiting"
      exports: ["RateLimiter"]
  key_links:
    - from: "ricochet/injection/http_client.py"
      to: "urllib.request"
      via: "urlopen with timeout"
      pattern: "urlopen.*timeout"
    - from: "ricochet/injection/rate_limiter.py"
      to: "time.monotonic"
      via: "token bucket timing"
      pattern: "time\\.monotonic"
---

<objective>
Build the HTTP client and rate limiting infrastructure for the injection engine.

Purpose: Enable sending HTTP requests with controlled timing to avoid target bans while supporting custom methods, headers, and bodies for injection payloads.

Output: `ricochet/injection/` package with rate-limited HTTP client.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-injection-engine/04-RESEARCH.md
@ricochet/core/store.py (existing InjectionStore for reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create injection package with rate limiter</name>
  <files>
    ricochet/injection/__init__.py
    ricochet/injection/rate_limiter.py
  </files>
  <action>
Create the `ricochet/injection/` package:

1. `__init__.py`: Export RateLimiter, HttpResponse, send_request (as they're created)

2. `rate_limiter.py`: Token bucket rate limiter
   - `RateLimiter` class with `__init__(rate: float, burst: int = 1)`
     - `rate`: requests per second
     - `burst`: max burst size (default 1 = no bursting)
   - `acquire(blocking: bool = True) -> bool` method
     - If blocking=True, wait until token available
     - If blocking=False, return False immediately if no token
     - Thread-safe using `threading.Lock()`
   - Use `time.monotonic()` for timing (not `time.time()` - avoids clock drift)
   - Refill tokens based on elapsed time: `tokens = min(burst, tokens + elapsed * rate)`

Critical: Release lock while sleeping to allow other threads to proceed.
  </action>
  <verify>
```python
python3 -c "
from ricochet.injection.rate_limiter import RateLimiter
import time
rl = RateLimiter(rate=10, burst=1)  # 10 req/s
start = time.time()
for _ in range(5):
    rl.acquire()
elapsed = time.time() - start
assert 0.35 < elapsed < 0.55, f'Expected ~0.4s, got {elapsed}'
print('Rate limiter OK')
"
```
  </verify>
  <done>RateLimiter class exists and correctly limits request rate to specified tokens/second</done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP client with timeout and error handling</name>
  <files>
    ricochet/injection/http_client.py
    ricochet/injection/__init__.py
  </files>
  <action>
Create `http_client.py` with stdlib-only HTTP client:

1. `HttpResponse` dataclass:
   - `status: int`
   - `reason: str`
   - `headers: dict[str, str]`
   - `body: bytes`
   - `url: str` (final URL after redirects)

2. `send_request()` function:
   ```python
   def send_request(
       url: str,
       method: str = 'GET',
       headers: Optional[dict] = None,
       body: Optional[bytes] = None,
       timeout: float = 10.0,
       verify_ssl: bool = True,
       follow_redirects: bool = True
   ) -> HttpResponse:
   ```

   Implementation:
   - Use `urllib.request.Request(url, data=body, headers=headers or {}, method=method)`
   - Create SSL context if `verify_ssl=False`: disable hostname check and cert verification
   - Use `urllib.request.urlopen(req, timeout=timeout, context=context)`
   - Handle `urllib.error.HTTPError` (4xx/5xx): still return HttpResponse with status code
   - Handle `urllib.error.URLError`: raise `ConnectionError` with clear message
   - Handle timeout: let `socket.timeout` propagate or wrap in `TimeoutError`

   **Redirect handling:**
   - If `follow_redirects=False`, create custom opener with no redirect handler
   - Use `urllib.request.build_opener()` without `HTTPRedirectHandler`

Update `__init__.py` to export `HttpResponse` and `send_request`.
  </action>
  <verify>
```bash
# Start a simple HTTP server in background
python3 -c "
from http.server import HTTPServer, BaseHTTPRequestHandler
import threading

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('X-Test', 'passed')
        self.end_headers()
        self.wfile.write(b'OK')
    def log_message(self, *args): pass

server = HTTPServer(('127.0.0.1', 19999), Handler)
thread = threading.Thread(target=server.handle_request)
thread.start()

# Test the client
from ricochet.injection.http_client import send_request, HttpResponse
resp = send_request('http://127.0.0.1:19999/test', timeout=5.0)
assert resp.status == 200
assert resp.body == b'OK'
assert 'X-Test' in resp.headers or 'x-test' in resp.headers
print('HTTP client OK')
thread.join()
"
```
  </verify>
  <done>send_request function sends HTTP requests with configurable timeout, method, headers, body, and returns HttpResponse with status, headers, body</done>
</task>

<task type="auto">
  <name>Task 3: Add timeout error handling and integration test</name>
  <files>
    ricochet/injection/http_client.py
  </files>
  <action>
Enhance error handling in `http_client.py`:

1. Wrap `socket.timeout` in clear `TimeoutError` with message including URL and timeout value

2. Add explicit timeout validation: raise `ValueError` if timeout <= 0

3. Create helper for Content-Length recalculation (needed when injecting into body):
   ```python
   def prepare_headers_for_body(headers: dict, body: Optional[bytes]) -> dict:
       """Ensure Content-Length matches actual body length."""
       result = dict(headers)
       if body is not None:
           result['Content-Length'] = str(len(body))
       return result
   ```

Test the timeout handling:
- Request to a non-routable IP (10.255.255.1) should raise TimeoutError within timeout period
- Request with very short timeout (0.001s) to any host should timeout quickly
  </action>
  <verify>
```python
python3 -c "
from ricochet.injection.http_client import send_request, prepare_headers_for_body
import time

# Test timeout handling
start = time.time()
try:
    send_request('http://10.255.255.1/', timeout=0.5)
    print('FAIL: should have timed out')
except (TimeoutError, ConnectionError) as e:
    elapsed = time.time() - start
    assert elapsed < 2.0, f'Took too long: {elapsed}s'
    print(f'Timeout OK ({elapsed:.2f}s)')

# Test Content-Length preparation
headers = {'User-Agent': 'test'}
body = b'test body content'
prepared = prepare_headers_for_body(headers, body)
assert prepared['Content-Length'] == '17'
assert prepared['User-Agent'] == 'test'
print('Content-Length preparation OK')
"
```
  </verify>
  <done>HTTP client properly handles timeouts, raises clear errors, and provides Content-Length helper for body injection</done>
</task>

</tasks>

<verification>
All tasks complete when:
1. `python3 -c "from ricochet.injection import RateLimiter, HttpResponse, send_request"` succeeds
2. Rate limiter correctly throttles requests to specified rate
3. HTTP client sends requests with custom method/headers/body
4. Timeout errors are raised within expected timeframe
5. Content-Length helper correctly updates headers
</verification>

<success_criteria>
- RateLimiter class implements thread-safe token bucket algorithm
- send_request function handles all HTTP methods, custom headers, request body
- Configurable timeout raises TimeoutError when exceeded
- All functions use stdlib only (urllib.request, time, threading)
- No external dependencies introduced
</success_criteria>

<output>
After completion, create `.planning/phases/04-injection-engine/04-01-SUMMARY.md`
</output>
