---
phase: 08-triggers-reporting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ricochet/triggers/__init__.py
  - ricochet/triggers/polling.py
  - ricochet/cli.py
  - tests/test_triggers_polling.py
autonomous: true

must_haves:
  truths:
    - "User can run passive mode that injects and polls for callbacks"
    - "Polling intervals start at 5s and back off to 60s on quiet periods"
    - "Polling resets to base interval when callback received"
    - "Passive mode times out after configurable duration"
  artifacts:
    - path: "ricochet/triggers/__init__.py"
      provides: "Module exports for polling"
    - path: "ricochet/triggers/polling.py"
      provides: "PollingStrategy and PollingConfig classes"
      exports: ["PollingStrategy", "PollingConfig", "poll_for_callbacks"]
    - path: "tests/test_triggers_polling.py"
      provides: "Unit tests for polling logic"
  key_links:
    - from: "ricochet/triggers/polling.py"
      to: "ricochet/core/store.py"
      via: "InjectionStore.get_findings()"
      pattern: "store\\.get_findings"
    - from: "ricochet/cli.py"
      to: "ricochet/triggers/polling.py"
      via: "cmd_passive import"
      pattern: "from ricochet\\.triggers\\.polling import"
---

<objective>
Implement passive polling mode for callback monitoring

Purpose: Enable users to inject payloads and continuously poll for callbacks with adaptive intervals, detecting second-order vulnerabilities that may trigger minutes or hours after injection.

Output: PollingStrategy class with exponential backoff, CLI `passive` subcommand, and integration with existing InjectionStore.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-triggers-reporting/08-RESEARCH.md

# Existing infrastructure
@ricochet/core/store.py
@ricochet/cli.py
@ricochet/output/finding.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create polling module with PollingStrategy</name>
  <files>ricochet/triggers/__init__.py, ricochet/triggers/polling.py</files>
  <action>
Create the triggers module with polling infrastructure:

1. Create `ricochet/triggers/__init__.py`:
   - Export PollingConfig, PollingStrategy, poll_for_callbacks

2. Create `ricochet/triggers/polling.py` with:
   - `PollingConfig` dataclass:
     - base_interval: float = 5.0 (seconds)
     - max_interval: float = 60.0 (seconds)
     - backoff_factor: float = 1.5
     - reset_on_callback: bool = True
     - timeout: float = 3600.0 (1 hour default)

   - `PollingStrategy` class:
     - __init__(config: PollingConfig)
     - get_next_interval(received_callback: bool) -> float
       - If callback received and reset_on_callback: reset to base_interval
       - Else: increment quiet poll counter
       - After 5 quiet polls: apply backoff (min(current * factor, max))
     - is_timed_out() -> bool
       - Track start_time on first call
       - Return True when elapsed > timeout

   - `poll_for_callbacks(store, config, callback) -> int`:
     - Poll loop that calls store.get_findings(since=last_poll_time)
     - Call user callback with new findings
     - Use PollingStrategy to determine sleep intervals
     - Exit on timeout or KeyboardInterrupt
     - Return count of total findings seen

Use time.monotonic() for timing (already established pattern in rate_limiter.py).
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -c "from ricochet.triggers.polling import PollingConfig, PollingStrategy, poll_for_callbacks; print('Imports OK')"
```
  </verify>
  <done>PollingConfig and PollingStrategy classes exist and are importable, get_next_interval implements exponential backoff</done>
</task>

<task type="auto">
  <name>Task 2: Add passive CLI subcommand</name>
  <files>ricochet/cli.py</files>
  <action>
Add `passive` subcommand to CLI for polling mode:

1. Add passive_parser after findings_parser:
   ```python
   passive_parser = subparsers.add_parser(
       'passive',
       help='Inject payloads and poll for callbacks (passive mode)'
   )
   ```

2. Add arguments:
   - Target specification (reuse inject group pattern):
     - -u/--url (mutually exclusive with -r)
     - -r/--request (Burp format file)
     - --from-crawl (crawl vectors JSON)
   - --payload (default: '{{CALLBACK}}')
   - --payloads (file path)
   - --callback-url (default: http://localhost:8080)
   - --rate (default: 10.0)
   - --timeout (default: 10.0) - request timeout
   - --poll-interval (default: 5.0) - base polling interval
   - --poll-timeout (default: 3600.0) - total passive mode duration
   - --proxy (proxy URL)
   - --dry-run

3. Create cmd_passive(args, store) -> int:
   - Reuse injection logic from cmd_inject
   - After injection completes, start polling loop
   - Use poll_for_callbacks with a callback that prints findings
   - Print summary when done (total findings, duration)

4. Set defaults: passive_parser.set_defaults(func=cmd_passive)
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -m ricochet passive --help
```
Should show passive mode options including --poll-interval and --poll-timeout.
  </verify>
  <done>`ricochet passive --help` shows polling options, command handler exists</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for polling logic</name>
  <files>tests/test_triggers_polling.py</files>
  <action>
Create tests for polling module:

1. Test PollingConfig defaults
2. Test PollingStrategy.get_next_interval:
   - Returns base_interval initially
   - Returns base_interval after callback (when reset_on_callback=True)
   - Applies backoff after 5 quiet polls
   - Never exceeds max_interval
3. Test PollingStrategy.is_timed_out:
   - Returns False initially
   - Returns True after timeout elapsed
4. Test poll_for_callbacks (mock store):
   - Calls store.get_findings with since parameter
   - Invokes callback with new findings
   - Respects timeout

Use pytest, follow existing test patterns from tests/test_payloads_*.py.
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -m pytest tests/test_triggers_polling.py -v
```
  </verify>
  <done>All polling tests pass, coverage includes backoff and timeout logic</done>
</task>

</tasks>

<verification>
```bash
cd /Users/aidan/projects/security/ricochet

# Module imports
python -c "from ricochet.triggers import PollingConfig, PollingStrategy, poll_for_callbacks"

# CLI command available
python -m ricochet passive --help | grep -E "(poll-interval|poll-timeout)"

# Tests pass
python -m pytest tests/test_triggers_polling.py -v

# Dry-run works (no actual requests)
echo 'GET /?test=value HTTP/1.1\nHost: example.com\n' > /tmp/test-req.txt
python -m ricochet passive -r /tmp/test-req.txt --dry-run --poll-timeout 1
```
</verification>

<success_criteria>
- PollingStrategy implements exponential backoff starting at 5s, capping at 60s
- Backoff triggers after 5 consecutive polls without callbacks
- Polling resets to base interval on callback receipt
- `ricochet passive` command injects then polls until timeout
- Unit tests verify backoff math and timeout behavior
</success_criteria>

<output>
After completion, create `.planning/phases/08-triggers-reporting/08-01-SUMMARY.md`
</output>
