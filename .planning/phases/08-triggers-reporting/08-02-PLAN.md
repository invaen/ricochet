---
phase: 08-triggers-reporting
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ricochet/triggers/active.py
  - ricochet/triggers/__init__.py
  - ricochet/cli.py
  - tests/test_triggers_active.py
autonomous: true

must_haves:
  truths:
    - "User can run active mode that attempts to trigger execution contexts"
    - "Active mode probes common admin/support/analytics endpoints"
    - "User can specify custom trigger endpoint list"
    - "Active mode respects rate limiting"
  artifacts:
    - path: "ricochet/triggers/active.py"
      provides: "ActiveTrigger class and endpoint catalog"
      exports: ["ActiveTrigger", "TRIGGER_ENDPOINTS"]
    - path: "tests/test_triggers_active.py"
      provides: "Unit tests for active trigger logic"
  key_links:
    - from: "ricochet/triggers/active.py"
      to: "ricochet/injection/http_client.py"
      via: "send_request for probing"
      pattern: "from ricochet\\.injection\\.http_client import"
    - from: "ricochet/cli.py"
      to: "ricochet/triggers/active.py"
      via: "cmd_active import"
      pattern: "from ricochet\\.triggers\\.active import"
---

<objective>
Implement active trigger mode for probing execution contexts

Purpose: Enable users to actively probe common second-order execution locations (admin panels, support dashboards, analytics) to trigger stored XSS payloads that would otherwise require manual admin access.

Output: ActiveTrigger class with endpoint catalog, CLI `active` subcommand, and rate-limited probing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-triggers-reporting/08-RESEARCH.md

# Existing infrastructure
@ricochet/injection/http_client.py
@ricochet/injection/rate_limiter.py
@ricochet/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create active trigger module with endpoint catalog</name>
  <files>ricochet/triggers/active.py, ricochet/triggers/__init__.py</files>
  <action>
Create active trigger infrastructure:

1. Create `ricochet/triggers/active.py` with:

   - `TRIGGER_ENDPOINTS` list (from research):
     ```python
     TRIGGER_ENDPOINTS = [
         # Admin/Management
         "/admin",
         "/admin/users",
         "/admin/logs",
         "/admin/reports",
         "/dashboard",
         "/manage",
         # Support/Helpdesk
         "/support",
         "/tickets",
         "/helpdesk",
         # Reporting/Analytics
         "/analytics",
         "/reports",
         "/stats",
         "/logs",
         # Content Management
         "/moderation",
         "/content",
         "/posts",
         "/comments",
         # Export Functions
         "/export",
         "/download",
         "/pdf",
         "/report/generate",
     ]
     ```

   - `TriggerResult` dataclass:
     - endpoint: str
     - status: int | None
     - error: str | None
     - response_size: int

   - `ActiveTrigger` class:
     - __init__(base_url: str, rate_limit: float = 2.0, timeout: float = 10.0, proxy_url: str | None = None)
     - probe_endpoint(endpoint: str) -> TriggerResult
       - Construct full URL from base_url + endpoint
       - Send GET request using http_client.send_request
       - Return TriggerResult with status/error
     - probe_all(endpoints: list[str] | None = None, callback: Callable | None = None) -> list[TriggerResult]
       - Use TRIGGER_ENDPOINTS if endpoints is None
       - Rate limit between requests
       - Call callback(result) after each probe if provided
       - Return all results

2. Update `ricochet/triggers/__init__.py`:
   - Add exports: ActiveTrigger, TRIGGER_ENDPOINTS, TriggerResult

Use RateLimiter from ricochet.injection.rate_limiter (established pattern).
Default rate of 2.0 req/s (slower than injection to avoid admin panel rate limits).
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -c "from ricochet.triggers.active import ActiveTrigger, TRIGGER_ENDPOINTS; print(f'{len(TRIGGER_ENDPOINTS)} endpoints')"
```
  </verify>
  <done>ActiveTrigger class exists with probe_endpoint and probe_all methods, TRIGGER_ENDPOINTS has 20+ common admin paths</done>
</task>

<task type="auto">
  <name>Task 2: Add active CLI subcommand</name>
  <files>ricochet/cli.py</files>
  <action>
Add `active` subcommand to CLI for trigger probing:

1. Add active_parser after passive_parser:
   ```python
   active_parser = subparsers.add_parser(
       'active',
       help='Probe common endpoints to trigger second-order execution (active mode)'
   )
   ```

2. Add arguments:
   - -u/--url (required): Base URL to probe (e.g., https://target.com)
   - --endpoints (optional): Path to file with custom endpoints (one per line)
   - --rate (default: 2.0): Requests per second
   - --timeout (default: 10.0): Request timeout
   - --proxy (optional): Proxy URL
   - -v/--verbose: Show response details

3. Create cmd_active(args, store) -> int:
   - Load custom endpoints from file if provided
   - Create ActiveTrigger with args
   - Print "Probing {N} endpoints on {url}"
   - Call probe_all with progress callback
   - Print results:
     - [+] /admin (200, 4523 bytes)
     - [-] /dashboard (404)
     - [!] /export (timeout)
   - Print summary: probed, successful (2xx), failed

4. Set defaults: active_parser.set_defaults(func=cmd_active)
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -m ricochet active --help
```
Should show active mode options including --endpoints and --rate.
  </verify>
  <done>`ricochet active --help` shows probing options, command handler exists</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for active trigger logic</name>
  <files>tests/test_triggers_active.py</files>
  <action>
Create tests for active trigger module:

1. Test TRIGGER_ENDPOINTS:
   - Contains expected paths (/admin, /support, /analytics)
   - All paths start with /

2. Test TriggerResult dataclass:
   - Fields accessible

3. Test ActiveTrigger.probe_endpoint (mock http_client):
   - Returns TriggerResult with status on success
   - Returns TriggerResult with error on timeout
   - Constructs correct URL from base_url + endpoint

4. Test ActiveTrigger.probe_all (mock):
   - Uses default endpoints when none provided
   - Uses custom endpoints when provided
   - Calls callback for each result
   - Returns all results

Use pytest with unittest.mock for http_client mocking.
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -m pytest tests/test_triggers_active.py -v
```
  </verify>
  <done>All active trigger tests pass, coverage includes endpoint construction and result handling</done>
</task>

</tasks>

<verification>
```bash
cd /Users/aidan/projects/security/ricochet

# Module imports
python -c "from ricochet.triggers import ActiveTrigger, TRIGGER_ENDPOINTS"

# CLI command available
python -m ricochet active --help | grep -E "(endpoints|rate)"

# Tests pass
python -m pytest tests/test_triggers_active.py -v

# Endpoint list is reasonable
python -c "from ricochet.triggers.active import TRIGGER_ENDPOINTS; print('\n'.join(TRIGGER_ENDPOINTS[:5]))"
```
</verification>

<success_criteria>
- TRIGGER_ENDPOINTS contains 20+ common admin/support/analytics paths
- ActiveTrigger probes endpoints with configurable rate limiting
- `ricochet active -u URL` probes all default endpoints
- `ricochet active -u URL --endpoints custom.txt` uses custom list
- Results show status codes and response sizes
</success_criteria>

<output>
After completion, create `.planning/phases/08-triggers-reporting/08-02-SUMMARY.md`
</output>
