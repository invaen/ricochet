---
phase: 02-http-callback-server
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - ricochet/cli.py
autonomous: true

must_haves:
  truths:
    - "User can run 'ricochet listen --http' to start callback server"
    - "Server binds to configurable host and port"
    - "Callbacks are logged to console as they arrive"
    - "Ctrl+C stops the server cleanly"
  artifacts:
    - path: "ricochet/cli.py"
      provides: "listen subcommand with --http, --host, --port"
      contains: "listen_parser"
  key_links:
    - from: "ricochet/cli.py"
      to: "ricochet/server/http.py"
      via: "import and call run_callback_server"
      pattern: "from ricochet\\.server\\.http import"
---

<objective>
Wire HTTP callback server to CLI with listen subcommand

Purpose: Allow users to start the callback server via `ricochet listen --http`
Output: Working CLI command that starts the server and handles shutdown
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-http-callback-server/02-RESEARCH.md
@.planning/phases/02-http-callback-server/02-01-PLAN.md

# Code to modify
@ricochet/cli.py

# Server module from 02-01 (will exist when this runs)
# ricochet/server/http.py provides: run_callback_server(host, port, store)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add listen subcommand to CLI</name>
  <files>ricochet/cli.py</files>
  <action>
Modify ricochet/cli.py to add the listen subcommand:

1. In create_parser(), after subparsers creation, add listen subcommand:

```python
# Listen command - callback server
listen_parser = subparsers.add_parser(
    'listen',
    help='Start callback server to receive OOB interactions'
)
listen_parser.add_argument(
    '--http',
    action='store_true',
    help='Start HTTP callback server'
)
listen_parser.add_argument(
    '--host',
    default='0.0.0.0',
    help='Host to bind to (default: 0.0.0.0)'
)
listen_parser.add_argument(
    '-p', '--port',
    type=int,
    default=8080,
    help='Port to listen on (default: 8080)'
)
listen_parser.set_defaults(func=cmd_listen)
```

2. Add cmd_listen function before main():

```python
def cmd_listen(args, store) -> int:
    """Handle listen subcommand - start callback server."""
    if args.http:
        from ricochet.server.http import run_callback_server
        return run_callback_server(args.host, args.port, store)
    else:
        print("Error: specify --http to start HTTP callback server", file=sys.stderr)
        print("  Example: ricochet listen --http", file=sys.stderr)
        return 2
```

Note: The lazy import of run_callback_server is intentional - only load server module when actually running listen command.
  </action>
  <verify>
1. Help check: `python -m ricochet listen --help` shows --http, --host, --port options
2. Error without --http: `python -m ricochet listen` exits with code 2 and shows error message
  </verify>
  <done>
- `ricochet listen --help` shows all options
- `ricochet listen` without --http shows helpful error message
- cmd_listen function imports and calls run_callback_server when --http provided
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end verification</name>
  <files>None (verification only)</files>
  <action>
Verify the complete workflow works:

1. Start server in background and test callback:
```bash
# Start server (will run in foreground, test manually or use timeout)
timeout 5 python -m ricochet listen --http --port 9999 &
sleep 1

# Send test request (no correlation ID, should work but log warning)
curl -s http://localhost:9999/test

# Send request with fake correlation ID format
curl -s http://localhost:9999/callback/abcd1234abcd1234

# Server should have logged requests
```

2. Verify database integration:
```python
from ricochet.core.store import InjectionStore, InjectionRecord
from ricochet.core.correlation import generate_correlation_id
import time

store = InjectionStore()
cid = generate_correlation_id()
print(f"Created injection with ID: {cid}")
print(f"Callback URL: http://localhost:8080/c/{cid}")

# Register an injection so callback will be recorded
store.record_injection(InjectionRecord(
    id=cid,
    target_url='http://example.com/test',
    parameter='name',
    payload='test payload',
    timestamp=time.time()
))

# Now if you curl the callback URL while server runs, it will be recorded
print("Start server: ricochet listen --http")
print(f"Then curl: curl http://localhost:8080/c/{cid}")
```
  </action>
  <verify>
1. `python -m ricochet listen --help` exits 0 with options shown
2. `python -m ricochet listen` exits 2 with error about --http
3. Server starts with `python -m ricochet listen --http --port 9999` and accepts requests
4. Ctrl+C stops server cleanly (exit 0 or 130)
  </verify>
  <done>
- listen --help shows HTTP callback server options
- listen without --http gives helpful error
- listen --http starts server that accepts HTTP requests
- Ctrl+C shuts down gracefully
- Callbacks with valid correlation IDs are persisted to database
  </done>
</task>

</tasks>

<verification>
1. CLI integration: `python -m ricochet listen --help`
2. Server starts: `timeout 3 python -m ricochet listen --http --port 9999 || true`
3. Full flow test (manual):
   - Terminal 1: `python -m ricochet listen --http --port 8080`
   - Terminal 2: Create injection, curl callback URL, verify in database
</verification>

<success_criteria>
- [ ] `ricochet listen --help` shows --http, --host, --port options
- [ ] `ricochet listen` without --http shows error with example usage
- [ ] `ricochet listen --http` starts server on 0.0.0.0:8080
- [ ] `ricochet listen --http --port 9999` uses custom port
- [ ] Server responds 200 OK to any HTTP request
- [ ] Server logs callback attempts to console
- [ ] Ctrl+C shuts down server cleanly
- [ ] Callbacks with known correlation IDs are stored in database
</success_criteria>

<output>
After completion, create `.planning/phases/02-http-callback-server/02-02-SUMMARY.md`
</output>
