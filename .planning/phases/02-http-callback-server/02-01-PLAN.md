---
phase: 02-http-callback-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ricochet/core/store.py
  - ricochet/server/__init__.py
  - ricochet/server/http.py
autonomous: true

must_haves:
  truths:
    - "Callback server accepts HTTP requests on any path"
    - "Correlation ID is extracted from URL path"
    - "Callbacks are persisted to database with full request details"
    - "Server handles concurrent requests without blocking"
    - "Server shuts down cleanly on Ctrl+C"
  artifacts:
    - path: "ricochet/server/http.py"
      provides: "CallbackHandler and CallbackServer classes"
      min_lines: 80
    - path: "ricochet/core/store.py"
      provides: "record_callback() and query methods"
      contains: "def record_callback"
  key_links:
    - from: "ricochet/server/http.py"
      to: "ricochet/core/store.py"
      via: "self.server.store.record_callback()"
      pattern: "store\\.record_callback"
---

<objective>
Implement HTTP callback server that captures OOB interactions and persists them to the database

Purpose: Enable detection of second-order vulnerabilities by receiving callbacks from injected payloads
Output: CallbackServer class with ThreadingHTTPServer, CallbackHandler with correlation ID extraction, store methods for recording and querying callbacks
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-http-callback-server/02-RESEARCH.md

# Existing code to extend
@ricochet/core/store.py
@ricochet/core/correlation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend InjectionStore with callback methods</name>
  <files>ricochet/core/store.py</files>
  <action>
Add to ricochet/core/store.py:

1. Add `import json` at top (needed for header serialization)

2. Add CallbackRecord dataclass after InjectionRecord:
```python
@dataclass
class CallbackRecord:
    """Record of a received callback."""
    id: int
    correlation_id: str
    source_ip: str
    request_path: str
    headers: dict
    body: bytes | None
    received_at: float
```

3. Add these methods to InjectionStore class:

record_callback() - Store a callback, return True if correlation ID exists:
- Parameters: correlation_id, source_ip, request_path, headers (dict), body (bytes|None)
- Check if injection exists via SELECT before INSERT (foreign key requires it)
- Serialize headers with json.dumps()
- Insert into callbacks table with time.time() for received_at
- Return True if inserted, False if correlation ID unknown

get_callbacks_for_injection() - Get all callbacks for a correlation ID:
- Parameter: correlation_id (str)
- SELECT from callbacks WHERE correlation_id = ? ORDER BY received_at DESC
- Parse headers back with json.loads()
- Return list[CallbackRecord]

get_injections_with_callbacks() - Get injections that have received callbacks:
- No parameters
- JOIN injections with callbacks, GROUP BY injection id
- COUNT callbacks, ORDER BY most recent callback
- Return list[tuple[InjectionRecord, int]] (record, callback_count)
  </action>
  <verify>
Python syntax check: `python -c "from ricochet.core.store import InjectionStore, CallbackRecord"`
  </verify>
  <done>
- CallbackRecord dataclass exists
- record_callback() method exists and returns bool
- get_callbacks_for_injection() method returns list[CallbackRecord]
- get_injections_with_callbacks() method returns list of tuples
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP callback server module</name>
  <files>ricochet/server/__init__.py, ricochet/server/http.py</files>
  <action>
Create ricochet/server/ directory and files:

1. Create ricochet/server/__init__.py:
```python
"""Callback server implementations."""
```

2. Create ricochet/server/http.py with:

Imports:
- http.server: BaseHTTPRequestHandler, ThreadingHTTPServer
- urllib.parse: urlparse
- signal, logging, typing

CallbackHandler(BaseHTTPRequestHandler):
- Override log_message() to use logging module instead of stderr
- _extract_correlation_id() method:
  - Parse self.path with urlparse()
  - Split path on '/', take last non-empty segment
  - Validate: exactly 16 chars, all hex (0-9, a-f lowercase)
  - Return correlation_id or None
- _handle_callback(body: bytes | None = None):
  - Extract correlation_id
  - Get source_ip from self.client_address[0]
  - If correlation_id found, call self.server.store.record_callback()
  - Log appropriately (info for found, warning for unknown, debug for no ID)
  - Always return 200 OK with "OK" body (don't leak valid/invalid IDs)
- do_GET, do_POST, do_HEAD, do_PUT, do_DELETE, do_OPTIONS, do_PATCH:
  - All call _handle_callback()
  - do_POST reads body from Content-Length header

CallbackServer(ThreadingHTTPServer):
- Set daemon_threads = True (class attribute)
- __init__(server_address, store): call super().__init__(), store self.store
- Set self.timeout = 0.5 for responsive shutdown
- serve_until_shutdown(): loop handle_request() while not _shutdown_event.is_set()
- request_shutdown(): set _shutdown_event

run_callback_server(host: str, port: int, store) -> int:
- Create CallbackServer instance
- Set up SIGINT and SIGTERM handlers to call server.request_shutdown()
- Print listening message with host:port
- Call server.serve_until_shutdown()
- Call server.server_close() in finally block
- Return 0
  </action>
  <verify>
Python syntax check: `python -c "from ricochet.server.http import CallbackServer, run_callback_server"`
  </verify>
  <done>
- ricochet/server/__init__.py exists
- ricochet/server/http.py exists with CallbackHandler, CallbackServer, run_callback_server
- Server uses ThreadingHTTPServer with daemon_threads = True
- Handler extracts 16-char hex correlation IDs from URL path
- Graceful shutdown via signal handlers
  </done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from ricochet.server.http import CallbackServer, run_callback_server; from ricochet.core.store import CallbackRecord"`
2. Quick integration test in Python REPL:
```python
from ricochet.core.store import InjectionStore, InjectionRecord
from ricochet.core.correlation import generate_correlation_id
import tempfile, time

# Create test store
with tempfile.NamedTemporaryFile(suffix='.db') as f:
    store = InjectionStore(f.name)
    cid = generate_correlation_id()
    store.record_injection(InjectionRecord(cid, 'http://test', 'param', 'payload', time.time()))
    result = store.record_callback(cid, '127.0.0.1', '/test/' + cid, {'User-Agent': 'test'}, None)
    assert result == True, "record_callback should return True for known ID"
    callbacks = store.get_callbacks_for_injection(cid)
    assert len(callbacks) == 1, "Should have 1 callback"
    with_callbacks = store.get_injections_with_callbacks()
    assert len(with_callbacks) == 1 and with_callbacks[0][1] == 1, "Should have 1 injection with 1 callback"
    print("All store tests passed")
```
</verification>

<success_criteria>
- [ ] CallbackRecord dataclass defined in store.py
- [ ] record_callback() persists callbacks and returns bool
- [ ] Query methods return proper data structures
- [ ] CallbackServer is ThreadingHTTPServer subclass with daemon_threads
- [ ] CallbackHandler extracts 16-char hex IDs from any URL path position
- [ ] All HTTP methods handled (GET, POST, HEAD, PUT, DELETE, OPTIONS, PATCH)
- [ ] Graceful shutdown on SIGINT/SIGTERM
- [ ] Integration test passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-http-callback-server/02-01-SUMMARY.md`
</output>
