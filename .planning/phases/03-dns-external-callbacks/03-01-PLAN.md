---
phase: 03-dns-external-callbacks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ricochet/server/dns.py
  - ricochet/cli.py
autonomous: true

must_haves:
  truths:
    - "User can start DNS callback server with ricochet listen --dns"
    - "DNS queries to correlation subdomains are captured and logged"
    - "Server responds to all DNS queries (prevents enumeration)"
  artifacts:
    - path: "ricochet/server/dns.py"
      provides: "DNS callback server implementation"
      exports: ["DNSHandler", "DNSCallbackServer", "run_dns_server"]
    - path: "ricochet/cli.py"
      provides: "--dns flag for listen subcommand"
      contains: "--dns"
  key_links:
    - from: "ricochet/cli.py"
      to: "ricochet/server/dns.py"
      via: "lazy import in cmd_listen"
      pattern: "from ricochet\\.server\\.dns import"
    - from: "ricochet/server/dns.py"
      to: "ricochet/core/store.py"
      via: "store.record_callback()"
      pattern: "store\\.record_callback"
---

<objective>
Implement a stdlib-only DNS callback server that captures correlation IDs from subdomain queries.

Purpose: DNS callbacks bypass firewalls that block HTTP outbound. This extends ricochet's detection capabilities for restricted environments where HTTP callbacks fail.

Output: Working DNS server at ricochet/server/dns.py with CLI integration via --dns flag.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dns-external-callbacks/03-RESEARCH.md

# Existing patterns to follow
@ricochet/server/http.py
@ricochet/cli.py
@ricochet/core/store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DNS callback server module</name>
  <files>ricochet/server/dns.py</files>
  <action>
Create DNS callback server following the HTTP server pattern from ricochet/server/http.py.

Implementation details:
- Use socketserver.ThreadingMixIn + socketserver.UDPServer (stdlib only)
- DNSHandler class extracts correlation ID from first subdomain label
- Correlation ID format: 16-char lowercase hex (same as HTTP)
- Store reference to InjectionStore via server.store (same pattern as HTTP)
- Always respond to DNS queries with 127.0.0.1 for A records (prevents enumeration and client retries)
- Use TYPE_CHECKING import for InjectionStore (same pattern as http.py)

DNS packet handling:
- Parse 12-byte header + question section using struct module
- Extract QNAME (domain name) from question section - labels are length-prefixed
- Handle compression pointers (0xC0 prefix) by ignoring them
- QTYPE follows QNAME (2 bytes, network order)
- Build response: copy txn_id, set response flags (0x8580), 1 question, 1 answer
- For A queries (QTYPE=1): return 127.0.0.1 with TTL 60
- For other queries: return empty answer (ANCOUNT=0)

Correlation extraction:
- Split QNAME by dots, take first label
- Validate: exactly 16 chars, all lowercase hex
- Record callback with request_path="DNS:{qname}" and headers={"qtype": str(qtype)}

run_dns_server() function:
- Same signature pattern as run_callback_server(host, port, store)
- Default port should be 5353 (high port, no root required)
- Signal handlers for SIGINT/SIGTERM
- Print "DNS callback server listening on {host}:{port}"
- Return exit code 0 on clean shutdown
  </action>
  <verify>
python -c "from ricochet.server.dns import DNSHandler, DNSCallbackServer, run_dns_server; print('imports ok')"
  </verify>
  <done>DNS server module exists with all three exports, follows http.py patterns</done>
</task>

<task type="auto">
  <name>Task 2: Wire DNS server to CLI</name>
  <files>ricochet/cli.py</files>
  <action>
Add --dns flag to listen subcommand and wire to dns server.

Changes to listen_parser:
- Add --dns argument (action='store_true', help='Start DNS callback server')
- Add --dns-port argument (type=int, default=5353, help='DNS port (default: 5353)')

Changes to cmd_listen():
- Add elif branch: if args.dns -> lazy import run_dns_server -> call run_dns_server(args.host, args.dns_port, store)
- Update error message: "Error: specify --http or --dns to start callback server"
- Keep lazy import pattern (only import when flag is used)

Do NOT change existing --http behavior.
  </action>
  <verify>
python -m ricochet listen --help | grep -E '(--dns|--dns-port)'
  </verify>
  <done>CLI shows --dns and --dns-port options in help output</done>
</task>

<task type="auto">
  <name>Task 3: End-to-end DNS callback verification</name>
  <files></files>
  <action>
Verify DNS callback capture works end-to-end.

Test procedure:
1. Create a test injection record with known correlation ID
2. Start DNS server in background
3. Send DNS query with correlation ID as subdomain using dig or nslookup
4. Verify callback was recorded in database

Commands:
```bash
# Terminal 1: Start DNS server (will run in background for test)
timeout 5 python -m ricochet listen --dns --dns-port 5354 &
sleep 1

# Terminal 2: Create test injection and query
python -c "
from ricochet.core.store import InjectionStore, InjectionRecord
import time
store = InjectionStore()
store.record_injection(InjectionRecord(
    id='a1b2c3d4e5f67890',
    target_url='http://test.local',
    parameter='test',
    payload='test',
    timestamp=time.time()
))
print('Injection recorded')
"

# Send DNS query
dig @127.0.0.1 -p 5354 a1b2c3d4e5f67890.callback.test.local A +short

# Check callback was recorded
python -c "
from ricochet.core.store import InjectionStore
store = InjectionStore()
callbacks = store.get_callbacks_for_injection('a1b2c3d4e5f67890')
print(f'Callbacks found: {len(callbacks)}')
if callbacks:
    print(f'Path: {callbacks[0].request_path}')
"
```

Expected: DNS server receives query, extracts correlation ID, records callback.
  </action>
  <verify>Callback count > 0 and request_path contains "DNS:"</verify>
  <done>DNS query with correlation subdomain triggers callback recording</done>
</task>

</tasks>

<verification>
All verification checks:
1. `python -c "from ricochet.server.dns import run_dns_server"` - imports without error
2. `python -m ricochet listen --help` shows --dns and --dns-port options
3. DNS server starts on specified port without root
4. DNS query with correlation subdomain records callback
5. DNS server responds to queries (no client timeout/retry)
</verification>

<success_criteria>
- DNS callback server captures correlation IDs from subdomain queries
- Server responds to all DNS queries with valid responses
- CLI --dns flag starts DNS server
- Callbacks are persisted to SQLite via existing store
- No external dependencies added (stdlib only)
</success_criteria>

<output>
After completion, create `.planning/phases/03-dns-external-callbacks/03-01-SUMMARY.md`
</output>
