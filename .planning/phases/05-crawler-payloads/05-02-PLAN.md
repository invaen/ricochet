---
phase: 05-crawler-payloads
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ricochet/injection/payloads.py
  - ricochet/injection/__init__.py
  - ricochet/cli.py
autonomous: true

must_haves:
  truths:
    - "User can provide --payloads file.txt to inject command"
    - "Each payload from file is injected with unique correlation ID"
    - "Comment lines starting with # are skipped"
    - "Blank lines are skipped"
    - "Payloads support {{CALLBACK}} placeholder substitution"
  artifacts:
    - path: "ricochet/injection/payloads.py"
      provides: "load_payloads function"
      exports: ["load_payloads"]
    - path: "ricochet/cli.py"
      provides: "--payloads argument on inject command"
      contains: "--payloads"
  key_links:
    - from: "ricochet/cli.py"
      to: "ricochet/injection/payloads.py"
      via: "import load_payloads"
      pattern: "from ricochet\\.injection\\.payloads import"
    - from: "ricochet/cli.py cmd_inject"
      to: "ricochet/injection/injector.py"
      via: "for loop iterating payloads list, calling injector.inject_single_param or inject_all_vectors for each payload"
      pattern: "for payload in payloads:.*inject"
---

<objective>
Implement custom payload file loading for the injection engine

Purpose: Enable users to provide their own payload files (SecLists, Wfuzz wordlists, custom payloads) for injection, with {{CALLBACK}} placeholder substitution for correlation tracking.

Output: Working `ricochet inject --payloads payloads.txt` option that injects each payload from the file.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-crawler-payloads/05-RESEARCH.md

# Existing injection infrastructure
@ricochet/injection/__init__.py
@ricochet/injection/injector.py
@ricochet/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payload loading module</name>
  <files>ricochet/injection/payloads.py</files>
  <action>
Create `ricochet/injection/payloads.py` with:

1. **load_payloads(filepath: Path) -> list[str]:**
   - Open file with encoding='utf-8'
   - Read line by line
   - Strip only trailing newlines (rstrip('\n\r'))
   - Skip lines starting with # (comments)
   - Skip empty lines
   - Return list of payload strings

2. **load_payloads_streaming(filepath: Path) -> Iterator[str]:**
   - Generator version for large files
   - Same filtering logic as load_payloads
   - Yields payloads one at a time

Include docstrings documenting:
- File format (one payload per line, # for comments, blank lines skipped)
- Raises FileNotFoundError if file doesn't exist
- Raises UnicodeDecodeError if file isn't valid UTF-8
- Compatible with SecLists, Wfuzz, and standard wordlist formats

Use imports:
- `from pathlib import Path`
- `from typing import Iterator`
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -c "from ricochet.injection.payloads import load_payloads, load_payloads_streaming; print('Imports OK')"
```
  </verify>
  <done>Payload loading module exists with both load_payloads and load_payloads_streaming functions</done>
</task>

<task type="auto">
  <name>Task 2: Add --payloads flag to inject command</name>
  <files>ricochet/cli.py, ricochet/injection/__init__.py</files>
  <action>
1. **Update ricochet/injection/__init__.py:**
   - Add import: `from ricochet.injection.payloads import load_payloads, load_payloads_streaming`
   - Add to __all__: "load_payloads", "load_payloads_streaming"

2. **Update ricochet/cli.py inject_parser:**
   Add after existing --payload argument:
   - `--payloads` with type=Path
   - Help text: 'File containing payloads (one per line, # for comments)'

3. **Update cmd_inject function:**
   After creating the injector, add payload loading logic:
   - If args.payloads is provided:
     - Check file exists, return 2 if not
     - Load payloads using load_payloads (lazy import)
     - Handle UnicodeDecodeError, return 2
     - Warn and return 0 if no payloads found
     - Print count of loaded payloads
   - Else: use [args.payload] as single-element list

   Modify injection loop to iterate over payloads list:
   - For --param mode: find matching vector, inject each payload into it
   - For all-vectors mode: inject each payload into all vectors
   - Collect all results into all_results list
   - Use all_results for display

This maintains backward compatibility with single --payload flag.
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
python -m ricochet inject --help | grep -A1 payloads
```
Expected: Shows --payloads option with description about file containing payloads
  </verify>
  <done>inject command shows --payloads flag in help output</done>
</task>

<task type="auto">
  <name>Task 3: Verify payload file loading and multi-payload injection</name>
  <files></files>
  <action>
Test payload loading and injection with a sample payload file:

1. Create test payload file with comments, blanks, and real payloads:
```bash
cd /Users/aidan/projects/security/ricochet
echo -e "# This is a comment\npayload1\npayload2\n\n# Another comment\npayload3" > /tmp/test-payloads.txt
```

2. Test load_payloads correctly filters comments and blanks:
```bash
python -c "
from pathlib import Path
from ricochet.injection.payloads import load_payloads
payloads = load_payloads(Path('/tmp/test-payloads.txt'))
assert len(payloads) == 3, f'Expected 3 payloads, got {len(payloads)}'
assert payloads == ['payload1', 'payload2', 'payload3'], f'Wrong payloads: {payloads}'
print('Payload loading verified: comments and blanks correctly skipped')
"
```

3. Test load_payloads_streaming returns same results:
```bash
python -c "
from pathlib import Path
from ricochet.injection.payloads import load_payloads_streaming
payloads = list(load_payloads_streaming(Path('/tmp/test-payloads.txt')))
assert payloads == ['payload1', 'payload2', 'payload3'], f'Streaming wrong: {payloads}'
print('Streaming verified')
"
```

4. Test FileNotFoundError handling:
```bash
python -c "
from pathlib import Path
from ricochet.injection.payloads import load_payloads
try:
    load_payloads(Path('/tmp/nonexistent-file.txt'))
    print('ERROR: Should have raised FileNotFoundError')
except FileNotFoundError:
    print('FileNotFoundError correctly raised')
"
```

5. Test {{CALLBACK}} placeholder in payload file:
```bash
echo -e "test{{CALLBACK}}payload\n<img src={{CALLBACK}}>" > /tmp/callback-payloads.txt
python -c "
from pathlib import Path
from ricochet.injection.payloads import load_payloads
payloads = load_payloads(Path('/tmp/callback-payloads.txt'))
assert '{{CALLBACK}}' in payloads[0], 'Placeholder not preserved'
print('Placeholder preserved in payloads')
"
```

6. Test dry-run injection with --payloads shows multiple injections with unique IDs:
```bash
python -m ricochet inject -u "http://example.com/search?q=test" --payloads /tmp/test-payloads.txt --dry-run 2>&1 | head -30
```
Expected: Shows 3 injection attempts (one per payload) with different correlation IDs

7. Clean up test files:
```bash
rm /tmp/test-payloads.txt /tmp/callback-payloads.txt 2>/dev/null || true
```
  </action>
  <verify>
```bash
cd /Users/aidan/projects/security/ricochet
echo -e "# Comment\npayload1\npayload2\n\npayload3" > /tmp/test-payloads.txt
python -c "
from pathlib import Path
from ricochet.injection.payloads import load_payloads, load_payloads_streaming

# Test basic loading
payloads = load_payloads(Path('/tmp/test-payloads.txt'))
assert len(payloads) == 3, f'Expected 3 payloads, got {len(payloads)}'
assert payloads == ['payload1', 'payload2', 'payload3'], f'Wrong payloads: {payloads}'

# Test streaming
stream_payloads = list(load_payloads_streaming(Path('/tmp/test-payloads.txt')))
assert stream_payloads == payloads, 'Streaming mismatch'

# Test FileNotFoundError
try:
    load_payloads(Path('/tmp/does-not-exist.txt'))
    assert False, 'Should raise FileNotFoundError'
except FileNotFoundError:
    pass

print('All payload loading assertions passed')
"
rm /tmp/test-payloads.txt
```
  </verify>
  <done>Payload file loading correctly skips comments and blank lines, streaming works, errors handled properly</done>
</task>

</tasks>

<verification>
1. `python -m ricochet inject --help` shows --payloads option
2. `python -c "from ricochet.injection.payloads import load_payloads"` imports without error
3. load_payloads correctly skips # comments and blank lines
4. load_payloads_streaming produces same results as load_payloads
5. FileNotFoundError raised for missing files
6. Dry-run with --payloads file shows multiple injections with unique correlation IDs
7. Each payload gets {{CALLBACK}} substituted with correlation URL
</verification>

<success_criteria>
- User can run `ricochet inject --payloads payloads.txt` and inject all payloads
- Comments (# prefix) and blank lines in payload files are skipped
- Each payload injection gets a unique correlation ID
- {{CALLBACK}} placeholder is substituted in each payload
- Backward compatible: single --payload still works
- load_payloads exported from ricochet.injection module
</success_criteria>

<output>
After completion, create `.planning/phases/05-crawler-payloads/05-02-SUMMARY.md`
</output>
