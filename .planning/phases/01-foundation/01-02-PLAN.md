---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - ricochet/core/store.py
  - ricochet/core/correlation.py
  - ricochet/cli.py
autonomous: true

must_haves:
  truths:
    - "Database file is created at ~/.ricochet/ricochet.db on first run"
    - "Database directory is created if it doesn't exist"
    - "Injection records persist across separate program runs"
    - "Foreign keys are enforced (callbacks reference valid injections)"
  artifacts:
    - path: "ricochet/core/store.py"
      provides: "SQLite persistence layer"
      exports: ["InjectionStore", "get_db_path", "InjectionRecord"]
      min_lines: 50
    - path: "ricochet/core/correlation.py"
      provides: "Correlation ID generation"
      exports: ["generate_correlation_id"]
      min_lines: 10
  key_links:
    - from: "ricochet/core/store.py"
      to: "~/.ricochet/ricochet.db"
      via: "sqlite3.connect()"
      pattern: "sqlite3\\.connect"
    - from: "ricochet/core/store.py"
      to: "foreign_keys"
      via: "PRAGMA statement"
      pattern: "PRAGMA foreign_keys = ON"
    - from: "ricochet/cli.py"
      to: "ricochet/core/store.py"
      via: "imports InjectionStore"
      pattern: "from ricochet\\.core\\.store import"
---

<objective>
Create the SQLite persistence layer for tracking injections and callbacks with proper schema and correlation ID generation.

Purpose: Enable Ricochet to persist injection records across sessions, which is essential for correlating callbacks that arrive hours or days after injection.
Output: Working database layer that initializes schema, records injections, and queries them back.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create correlation ID generator</name>
  <files>ricochet/core/correlation.py</files>
  <action>
    Create the correlation ID generator module:

    1. Create `ricochet/core/correlation.py` with:
       - Import secrets
       - `generate_correlation_id()` function that:
         - Returns secrets.token_hex(8) (16 hex characters)
         - Has docstring explaining format and why it's URL-safe
       - Keep IDs alphanumeric only (hex characters) per research pitfall #5

    Why 16 characters:
    - Short enough to survive truncation in most contexts
    - Long enough to avoid collisions (16^16 = 18 quintillion)
    - Hex-only means no URL encoding issues
  </action>
  <verify>
    ```bash
    python3 -c "from ricochet.core.correlation import generate_correlation_id; id = generate_correlation_id(); print(f'ID: {id}, len: {len(id)}, is_alnum: {id.isalnum()}')"
    ```
    Should show 16-character alphanumeric ID
  </verify>
  <done>generate_correlation_id() returns 16-char hex string</done>
</task>

<task type="auto">
  <name>Task 2: Create SQLite store</name>
  <files>ricochet/core/store.py</files>
  <action>
    Create the SQLite persistence layer following Pattern 2 from research:

    1. Create `ricochet/core/store.py` with:
       - Imports: sqlite3, pathlib.Path, typing.Optional, dataclasses, time

       - `get_db_path()` function:
         - Returns Path.home() / '.ricochet' / 'ricochet.db'
         - Creates parent directory with mkdir(parents=True, exist_ok=True)

       - `@dataclass InjectionRecord`:
         - id: str (correlation ID)
         - target_url: str
         - parameter: str
         - payload: str
         - timestamp: float
         - context: Optional[str] = None

       - `class InjectionStore`:
         - __init__(self, db_path: Path = None):
           - Uses get_db_path() if db_path is None
           - Stores self.db_path
           - Calls self._init_db()

         - _get_connection(self) -> sqlite3.Connection:
           - conn = sqlite3.connect(str(self.db_path))
           - conn.execute("PRAGMA foreign_keys = ON")  # CRITICAL per research
           - conn.row_factory = sqlite3.Row
           - return conn

         - _init_db(self):
           - Creates injections table: id PRIMARY KEY, target_url, parameter, payload, context, injected_at
           - Creates callbacks table: id AUTOINCREMENT, correlation_id, source_ip, request_path, headers, body, received_at, FOREIGN KEY to injections
           - Creates indexes on callbacks(correlation_id) and injections(injected_at)
           - Uses executescript() with CREATE TABLE IF NOT EXISTS

         - record_injection(self, record: InjectionRecord) -> None:
           - Inserts injection record

         - get_injection(self, correlation_id: str) -> Optional[InjectionRecord]:
           - Queries by ID, returns None if not found

         - list_injections(self, limit: int = 100) -> list[InjectionRecord]:
           - Returns recent injections ordered by timestamp DESC
  </action>
  <verify>
    ```bash
    python3 << 'EOF'
from ricochet.core.store import InjectionStore, InjectionRecord, get_db_path
from ricochet.core.correlation import generate_correlation_id
import time
import os

# Use temp path for test
test_db = get_db_path().parent / 'test_ricochet.db'
store = InjectionStore(test_db)

# Create injection
record = InjectionRecord(
    id=generate_correlation_id(),
    target_url='https://example.com/submit',
    parameter='name',
    payload='<script>alert(1)</script>',
    timestamp=time.time()
)
store.record_injection(record)

# Read it back
retrieved = store.get_injection(record.id)
print(f"Stored and retrieved: {retrieved.target_url}")
print(f"ID matches: {retrieved.id == record.id}")

# List injections
all_records = store.list_injections()
print(f"Total injections: {len(all_records)}")

# Cleanup
os.remove(test_db)
print("Test passed!")
EOF
    ```
  </verify>
  <done>InjectionStore creates DB, stores and retrieves injection records</done>
</task>

<task type="auto">
  <name>Task 3: Wire store initialization into CLI</name>
  <files>ricochet/cli.py</files>
  <action>
    Update cli.py to initialize the store on startup:

    1. Add imports at top:
       - from ricochet.core.store import InjectionStore, get_db_path

    2. In main() function, after parsing args:
       - Get db_path from args.db or get_db_path()
       - Create store = InjectionStore(db_path)
       - This ensures database exists on first run

    3. Pass store to subcommand handlers (for future use):
       - Modify any args.func() calls to pass store as second argument
       - Pattern: return args.func(args, store) if hasattr(args, 'func') else 0

    NOTE: Don't add any new subcommands. Just wire up the store initialization.
    The database should be created when any ricochet command runs.
  </action>
  <verify>
    ```bash
    # Remove existing DB to test fresh creation
    rm -f ~/.ricochet/ricochet.db

    # Run any command to trigger initialization
    python3 -m ricochet --help

    # Check database was created
    ls -la ~/.ricochet/
    sqlite3 ~/.ricochet/ricochet.db ".schema"
    ```
    Should show:
    - ~/.ricochet/ directory exists
    - ricochet.db file exists
    - Schema shows injections and callbacks tables
  </verify>
  <done>Running ricochet creates database at ~/.ricochet/ricochet.db with schema</done>
</task>

</tasks>

<verification>
Run all verification commands:

```bash
# Fresh start
rm -rf ~/.ricochet/

# Run CLI to trigger DB creation
python3 -m ricochet --help

# Verify DB structure
echo "=== Directory ===" && ls -la ~/.ricochet/
echo "=== Schema ===" && sqlite3 ~/.ricochet/ricochet.db ".schema"
echo "=== Foreign keys ===" && sqlite3 ~/.ricochet/ricochet.db "PRAGMA foreign_keys"

# Test persistence across runs
python3 << 'EOF'
from ricochet.core.store import InjectionStore, InjectionRecord, get_db_path
from ricochet.core.correlation import generate_correlation_id
import time

store = InjectionStore()
record = InjectionRecord(
    id=generate_correlation_id(),
    target_url='https://test.com',
    parameter='q',
    payload='test',
    timestamp=time.time()
)
store.record_injection(record)
print(f"Recorded: {record.id}")
EOF

# Verify record persists in new process
python3 << 'EOF'
from ricochet.core.store import InjectionStore
store = InjectionStore()
records = store.list_injections()
print(f"Found {len(records)} injection(s) from previous run")
for r in records:
    print(f"  - {r.id}: {r.target_url}")
EOF
```
</verification>

<success_criteria>
- Database created at ~/.ricochet/ricochet.db on first run
- Schema includes injections and callbacks tables
- Foreign key constraint exists between callbacks and injections
- Injection records persist across program runs
- get_db_path() creates directory if missing
- InjectionStore works with custom db_path
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
