---
phase: 07-correlation-output
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - ricochet/output/formatters.py
  - ricochet/output/__init__.py
  - ricochet/cli.py
autonomous: true

must_haves:
  truths:
    - "User can get findings in JSON format with -o json"
    - "User can get human-readable output with -o text"
    - "User can enable verbose/debug mode to see payloads and responses"
  artifacts:
    - path: "ricochet/output/formatters.py"
      provides: "output_json() and output_text() functions"
      exports: ["output_json", "output_text"]
    - path: "ricochet/cli.py"
      provides: "findings subcommand with -o and -v options"
      contains: "findings"
  key_links:
    - from: "ricochet/cli.py"
      to: "ricochet/output/formatters.py"
      via: "calls output_json or output_text based on -o flag"
      pattern: "output_(json|text)\\(findings"
    - from: "ricochet/output/formatters.py"
      to: "ricochet/output/finding.py"
      via: "accepts list[Finding]"
      pattern: "list\\[Finding\\]"
---

<objective>
Create output formatters for findings (JSON/text) and add findings CLI command

Purpose: Allow users to view and export correlated findings in their preferred format
Output: formatters.py with output_json/output_text, findings CLI subcommand
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-correlation-output/07-RESEARCH.md

# Depends on 07-01 for Finding dataclass
@.planning/phases/07-correlation-output/07-01-SUMMARY.md

@ricochet/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create output formatters (JSON and text)</name>
  <files>ricochet/output/formatters.py, ricochet/output/__init__.py</files>
  <action>
Create formatters.py with JSON and text output functions:

1. Create ricochet/output/formatters.py:

```python
"""Output formatters for findings (JSON, text)."""

import json
import sys
from datetime import datetime, timezone
from typing import TextIO

from ricochet.output.finding import Finding


def output_json(
    findings: list[Finding],
    file: TextIO = sys.stdout,
    verbose: bool = False
) -> None:
    """Output findings in JSONL format (one JSON object per line).

    Args:
        findings: List of Finding objects to output
        file: Output stream (default: stdout)
        verbose: Include full payload and callback body
    """
    for finding in findings:
        record = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "tool": "ricochet",
            "finding": {
                "correlation_id": finding.correlation_id,
                "severity": finding.severity,
                "injection": {
                    "target_url": finding.target_url,
                    "parameter": finding.parameter,
                    "injected_at": finding.injected_at,
                    "context": finding.context,
                },
                "callback": {
                    "source_ip": finding.source_ip,
                    "request_path": finding.request_path,
                    "received_at": finding.received_at,
                    "delay_seconds": round(finding.delay_seconds, 2),
                },
            }
        }

        if verbose:
            record["finding"]["injection"]["payload"] = finding.payload
            record["finding"]["callback"]["headers"] = finding.callback_headers
            if finding.callback_body:
                # Attempt to decode, fall back to base64
                try:
                    record["finding"]["callback"]["body"] = finding.callback_body.decode('utf-8')
                except (UnicodeDecodeError, AttributeError):
                    import base64
                    record["finding"]["callback"]["body_base64"] = base64.b64encode(
                        finding.callback_body if isinstance(finding.callback_body, bytes)
                        else finding.callback_body.encode()
                    ).decode('ascii')

        print(json.dumps(record), file=file)


def output_text(
    findings: list[Finding],
    file: TextIO = sys.stdout,
    verbose: bool = False
) -> None:
    """Output findings in human-readable text format.

    Args:
        findings: List of Finding objects to output
        file: Output stream (default: stdout)
        verbose: Include full payload and callback details
    """
    if not findings:
        print("No findings.", file=file)
        return

    print(f"=== Ricochet Findings ({len(findings)}) ===", file=file)
    print(file=file)

    severity_icons = {
        'high': '[!]',
        'medium': '[+]',
        'low': '[*]',
        'info': '[-]',
    }

    for i, f in enumerate(findings, 1):
        icon = severity_icons.get(f.severity, '[-]')

        print(f"{icon} Finding #{i}", file=file)
        print(f"    Correlation ID: {f.correlation_id}", file=file)
        print(f"    Target: {f.target_url}", file=file)
        print(f"    Parameter: {f.parameter}", file=file)
        print(f"    Severity: {f.severity.upper()}", file=file)
        print(f"    Delay: {f.delay_seconds:.2f}s", file=file)

        if verbose:
            print(file=file)
            print(f"    Payload: {f.payload}", file=file)
            print(f"    Context: {f.context}", file=file)
            print(f"    Callback from: {f.source_ip}", file=file)
            print(f"    Callback path: {f.request_path}", file=file)
            if f.callback_headers:
                print(f"    Callback headers: {f.callback_headers}", file=file)

        print(file=file)
```

2. Update ricochet/output/__init__.py to export formatters:
```python
from ricochet.output.finding import Finding
from ricochet.output.formatters import output_json, output_text

__all__ = ["Finding", "output_json", "output_text"]
```
  </action>
  <verify>python -c "from ricochet.output import output_json, output_text; print('formatters imported')"</verify>
  <done>output_json and output_text functions created and exported</done>
</task>

<task type="auto">
  <name>Task 2: Add findings subcommand to CLI</name>
  <files>ricochet/cli.py</files>
  <action>
Add findings subcommand to display correlated findings:

1. In create_parser(), add findings subparser (after crawl_parser):

```python
# Findings command - show correlated findings
findings_parser = subparsers.add_parser(
    'findings',
    help='Show correlated findings (injections that received callbacks)'
)
findings_parser.add_argument(
    '-o', '--output',
    choices=['json', 'text'],
    default='text',
    help='Output format (default: text)'
)
findings_parser.add_argument(
    '--since',
    metavar='HOURS',
    type=float,
    help='Only show findings from last N hours'
)
findings_parser.add_argument(
    '--min-severity',
    choices=['info', 'low', 'medium', 'high'],
    default='info',
    help='Minimum severity to show (default: info)'
)
findings_parser.set_defaults(func=cmd_findings)
```

2. Create cmd_findings() function:

```python
def cmd_findings(args, store) -> int:
    """Handle findings subcommand - show correlated findings.

    Args:
        args: Parsed command line arguments.
        store: InjectionStore instance.

    Returns:
        Exit code (0 for success).
    """
    from ricochet.output import output_json, output_text
    import time

    # Calculate since timestamp if provided
    since = None
    if args.since:
        since = time.time() - (args.since * 3600)  # hours to seconds

    # Get findings from store
    findings = store.get_findings(
        since=since,
        min_severity=args.min_severity
    )

    # Output in requested format
    # Use args.verbose from global -v flag
    verbose = getattr(args, 'verbose', 0) > 0

    if args.output == 'json':
        output_json(findings, verbose=verbose)
    else:
        output_text(findings, verbose=verbose)

    return 0
```

3. Ensure the global -v/--verbose flag (already exists in create_parser) is accessible in cmd_findings via args.verbose.
  </action>
  <verify>cd /Users/aidan/projects/security/ricochet && python -m ricochet findings --help</verify>
  <done>findings subcommand shows help with -o, --since, --min-severity options</done>
</task>

<task type="auto">
  <name>Task 3: Configure logging based on verbosity level</name>
  <files>ricochet/cli.py</files>
  <action>
Add logging configuration based on -v flag count:

1. Create setup_logging() function in cli.py:

```python
import logging

def setup_logging(verbosity: int) -> None:
    """Configure logging based on verbosity level.

    Args:
        verbosity: Count from argparse (0=warning, 1=info, 2+=debug)
    """
    # Map verbosity to log level: 0->WARNING, 1->INFO, 2+->DEBUG
    level = logging.WARNING - (verbosity * 10)
    level = max(level, logging.DEBUG)  # Don't go below DEBUG

    # Configure format based on level
    if level <= logging.DEBUG:
        fmt = '%(asctime)s %(levelname)s %(name)s: %(message)s'
    else:
        fmt = '%(levelname)s: %(message)s'

    logging.basicConfig(
        level=level,
        format=fmt,
        stream=sys.stderr,  # Logs to stderr, findings to stdout
    )
```

2. In main(), call setup_logging() after parsing args:

```python
def main() -> int:
    try:
        parser = create_parser()
        args = parser.parse_args()

        # Set up logging based on verbosity
        setup_logging(args.verbose)

        # ... rest of main
```

3. Add import for logging at top of file.

Note: The -v/--verbose argument already exists and uses action='count'. This just wires it to the logging module.
  </action>
  <verify>cd /Users/aidan/projects/security/ricochet && python -m ricochet -vv findings --help 2>&1 | head -5</verify>
  <done>Logging configured based on -v count, logs go to stderr</done>
</task>

</tasks>

<verification>
1. Formatters import: `python -c "from ricochet.output import output_json, output_text, Finding; print('OK')"`
2. Findings command exists: `cd /Users/aidan/projects/security/ricochet && python -m ricochet findings --help`
3. JSON output works: `cd /Users/aidan/projects/security/ricochet && python -m ricochet findings -o json`
4. Text output works: `cd /Users/aidan/projects/security/ricochet && python -m ricochet findings -o text`
5. Verbose flag works: `cd /Users/aidan/projects/security/ricochet && python -m ricochet -v findings -o text`
6. Tests pass: `cd /Users/aidan/projects/security/ricochet && python -m pytest tests/ -v --tb=short 2>/dev/null || echo 'No tests or tests passed'`
</verification>

<success_criteria>
1. output_json() outputs JSONL format (one JSON per line)
2. output_text() outputs human-readable format with severity icons
3. findings subcommand works with -o json and -o text
4. --since filters by time window
5. --min-severity filters by severity level
6. -v flag enables verbose output (shows payloads, full callback details)
7. Logs go to stderr, findings go to stdout
</success_criteria>

<output>
After completion, create `.planning/phases/07-correlation-output/07-02-SUMMARY.md`
</output>
