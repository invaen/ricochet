---
phase: 07-correlation-output
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ricochet/output/__init__.py
  - ricochet/output/finding.py
  - ricochet/core/store.py
autonomous: true

must_haves:
  truths:
    - "Tool can identify which injection triggered a specific callback"
    - "Finding includes both injection details and callback details"
    - "Severity is derived from vulnerability context (ssti/sqli=high, xss=medium)"
  artifacts:
    - path: "ricochet/output/finding.py"
      provides: "Finding dataclass with severity derivation"
      contains: "class Finding"
    - path: "ricochet/output/__init__.py"
      provides: "Output module exports"
      exports: ["Finding"]
    - path: "ricochet/core/store.py"
      provides: "get_findings() correlation query"
      contains: "def get_findings"
  key_links:
    - from: "ricochet/core/store.py"
      to: "ricochet/output/finding.py"
      via: "imports Finding, returns list[Finding]"
      pattern: "from ricochet\\.output\\.finding import Finding"
---

<objective>
Create the correlation engine that joins callbacks with their originating injections

Purpose: Enable the tool to answer "which injection caused this callback?" - the core value proposition
Output: Finding dataclass and get_findings() query method in InjectionStore
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-correlation-output/07-RESEARCH.md

@ricochet/core/store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Finding dataclass in new output module</name>
  <files>ricochet/output/__init__.py, ricochet/output/finding.py</files>
  <action>
Create new output module with Finding dataclass:

1. Create ricochet/output/__init__.py that exports Finding

2. Create ricochet/output/finding.py with:
   - Finding dataclass with fields:
     - correlation_id: str
     - target_url: str
     - parameter: str
     - payload: str
     - context: Optional[str]
     - injected_at: float
     - callback_id: int
     - source_ip: str
     - request_path: str
     - callback_headers: dict
     - callback_body: Optional[bytes]
     - received_at: float
     - delay_seconds: float

   - @property severity that derives from context:
     - 'ssti' in context.lower() -> 'high'
     - 'sqli' in context.lower() -> 'high'
     - 'xss' in context.lower() -> 'medium'
     - default -> 'info'

   - Handle None context safely (check before .lower())

Follow existing dataclass patterns in ricochet/core/store.py.
  </action>
  <verify>python -c "from ricochet.output.finding import Finding; f = Finding(correlation_id='abc', target_url='http://x', parameter='p', payload='x', context='xss:html', injected_at=0, callback_id=1, source_ip='127.0.0.1', request_path='/', callback_headers={}, callback_body=None, received_at=1, delay_seconds=1); print(f.severity)"</verify>
  <done>Finding dataclass created with severity property returning 'medium' for xss context</done>
</task>

<task type="auto">
  <name>Task 2: Add get_findings() correlation query to InjectionStore</name>
  <files>ricochet/core/store.py</files>
  <action>
Add get_findings() method to InjectionStore class:

1. Import Finding from ricochet.output.finding at top of file

2. Add get_findings() method with signature:
   ```python
   def get_findings(
       self,
       since: Optional[float] = None,
       min_severity: str = 'info'
   ) -> list[Finding]:
   ```

3. SQL query using INNER JOIN:
   ```sql
   SELECT
       i.id as correlation_id,
       i.target_url,
       i.parameter,
       i.payload,
       i.context,
       i.injected_at,
       c.id as callback_id,
       c.source_ip,
       c.request_path,
       c.headers as callback_headers,
       c.body as callback_body,
       c.received_at,
       (c.received_at - i.injected_at) as delay_seconds
   FROM injections i
   INNER JOIN callbacks c ON i.id = c.correlation_id
   ```

4. Add WHERE clause if since is provided: `c.received_at > ?`

5. Order by `c.received_at DESC`

6. Convert rows to Finding objects:
   - Parse headers JSON: json.loads(row['callback_headers']) if row['callback_headers'] else {}
   - Handle body bytes properly (may be str in sqlite)

7. Filter by min_severity AFTER creating Finding (severity is derived):
   - severity_order = {'info': 0, 'low': 1, 'medium': 2, 'high': 3}
   - Only include if finding.severity >= min_severity in order

Note: The existing json import is already present in store.py.
  </action>
  <verify>python -c "from ricochet.core.store import InjectionStore; s = InjectionStore(); print(type(s.get_findings()))"</verify>
  <done>get_findings() returns list of Finding objects (empty list when no callbacks exist)</done>
</task>

</tasks>

<verification>
1. Import chain works: `python -c "from ricochet.output import Finding; from ricochet.core.store import InjectionStore"`
2. Finding severity works: `python -c "from ricochet.output import Finding; f = Finding('a','b','c','d','sqli:mssql',0,1,'ip','/p',{},None,1,1); print(f.severity)"` -> prints 'high'
3. get_findings() callable: `python -c "from ricochet.core.store import InjectionStore; s = InjectionStore(); print(s.get_findings())"` -> prints []
4. Tests pass if any: `cd /Users/aidan/projects/security/ricochet && python -m pytest tests/ -v --tb=short 2>/dev/null || echo 'No tests or tests passed'`
</verification>

<success_criteria>
1. Finding dataclass exists with all required fields
2. Finding.severity property derives severity from context string
3. InjectionStore.get_findings() returns list[Finding] via INNER JOIN
4. Empty database returns empty list (not error)
5. Filtering by since and min_severity works
</success_criteria>

<output>
After completion, create `.planning/phases/07-correlation-output/07-01-SUMMARY.md`
</output>
